import { TSESTree } from '@typescript-eslint/types';
import type { Scope } from './scope.js';
import { BlockScope, CatchScope, ClassScope, ConditionalTypeScope, ForScope, FunctionExpressionNameScope, FunctionScope, FunctionTypeScope, GlobalScope, MappedTypeScope, ModuleScope, SwitchScope, TSEnumScope, TSModuleScope, TypeScope, WithScope } from './scope.js';
import { ClassFieldInitializerScope } from './scope/ClassFieldInitializerScope.js';
import { ClassStaticBlockScope } from './scope/ClassStaticBlockScope.js';
import type { Variable } from './variable.js';
interface ScopeManagerOptions {
    globalReturn?: boolean;
    sourceType?: 'module' | 'script';
    impliedStrict?: boolean;
    ecmaVersion?: number;
}
declare class ScopeManager {
    #private;
    currentScope: Scope | null;
    readonly declaredVariables: WeakMap<TSESTree.Node, Variable[]>;
    /**
     * The root scope
     * @public
     */
    globalScope: GlobalScope | null;
    readonly nodeToScope: WeakMap<TSESTree.Node, Scope[]>;
    /**
     * All scopes
     * @public
     */
    readonly scopes: Scope[];
    get variables(): Variable[];
constructor(options: ScopeManagerOptions);
constructor(): boolean;
constructor(): boolean;
constructor(): boolean;
constructor(): boolean;
constructor(): boolean;
    /**
     * Get the variables that a given AST node defines. The gotten variables' `def[].node`/`def[].parent` property is the node.
     * If the node does not define any variable, this returns an empty array.
     * @param node An AST node to get their variables.
     * @public
     */
constructor(node: TSESTree.Node): Variable[];
    /**
     * Get the scope of a given AST node. The gotten scope's `block` property is the node.
     * This method never returns `function-expression-name` scope. If the node does not have their scope, this returns `null`.
     *
     * @param node An AST node to get their scope.
     * @param inner If the node has multiple scopes, this returns the outermost scope normally.
     *                If `inner` is `true` then this returns the innermost scope.
     * @public
     */
constructor(node: TSESTree.Node, inner?: boolean): Scope | null;
    protected nestScope<T extends Scope>(scope: T): T;
constructor(node: BlockScope['block']): BlockScope;
constructor(node: CatchScope['block']): CatchScope;
constructor(node: ClassScope['block']): ClassScope;
constructor(node: ClassFieldInitializerScope['block']): ClassFieldInitializerScope;
constructor(node: ClassStaticBlockScope['block']): ClassStaticBlockScope;
constructor(node: ConditionalTypeScope['block']): ConditionalTypeScope;
constructor(node: ForScope['block']): ForScope;
constructor(node: FunctionExpressionNameScope['block']): FunctionExpressionNameScope;
constructor(node: FunctionScope['block'], isMethodDefinition: boolean): FunctionScope;
constructor(node: FunctionTypeScope['block']): FunctionTypeScope;
constructor(node: GlobalScope['block']): GlobalScope;
constructor(node: MappedTypeScope['block']): MappedTypeScope;
constructor(node: ModuleScope['block']): ModuleScope;
constructor(node: SwitchScope['block']): SwitchScope;
constructor(node: TSEnumScope['block']): TSEnumScope;
constructor(node: TSModuleScope['block']): TSModuleScope;
constructor(node: TypeScope['block']): TypeScope;
constructor(node: WithScope['block']): WithScope;
}
export { ScopeManager };
//# sourceMappingURL=ScopeManager.d.ts.map