import { describe, it, expect, beforeEach } from 'vitest';
import { load, type CheerioAPI, type Cheerio } from '../index.js';
import type { Element } from 'domhandler';
import {
  cheerio,
  script,
  fruits,
  vegetables,
  food,
  chocolates,
  inputs,
  mixedText,
} from '../__fixtures__/fixtures.js';
function withClass(attr: string) {
  return cheerio(`<div class="${attr}"></div>`);
}
constructor('$(...)', () => {
constructor('.attr', () => {
    let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
      $ = load(fruits);
    });
constructor('() : should get all the attributes', () => {
      const attrs = $('ul').attr();
constructor(attrs).toHaveProperty('id', 'fruits');
    });
constructor('(invalid key) : invalid attr should get undefined', () => {
      const attr = $('.apple').attr('lol');
constructor(attr).toBeUndefined();
    });
constructor('(valid key) : valid attr should get value', () => {
      const cls = $('.apple').attr('class');
constructor(cls).toBe('apple');
    });
constructor('(valid key) : valid attr should get name when boolean', () => {
      const attr = $('<input name=email autofocus>').attr('autofocus');
constructor(attr).toBe('autofocus');
    });
constructor('(key, value) : should set one attr', () => {
      const $pear = $('.pear').attr('id', 'pear');
constructor($('#pear')).toHaveLength(1);
constructor($pear).toBeInstanceOf($);
    });
constructor('(key, value) : should set multiple attr', () => {
      const $el = cheerio('<div></div> <div></div>').attr(
        'class',
        'pear',
      ) as Cheerio<Element>;
constructor($el[0].attribs).toHaveProperty('class', 'pear');
constructor($el[1].attribs).toBeUndefined();
constructor($el[2].attribs).toHaveProperty('class', 'pear');
    });
constructor('(key, value) : should return an empty object for an empty object', () => {
      const $src = $().attr('key', 'value');
constructor($src.length).toBe(0);
constructor($src[0]).toBeUndefined();
    });
constructor('(map) : object map should set multiple attributes', () => {
      $('.apple').attr({
        id: 'apple',
        style: 'color:red;',
        'data-url': 'http://apple.com',
      });
      const attrs = $('.apple').attr();
constructor(attrs).toHaveProperty('id', 'apple');
constructor(attrs).toHaveProperty('style', 'color:red;');
constructor(attrs).toHaveProperty('data-url', 'http://apple.com');
    });
constructor('(map, val) : should throw with wrong combination of arguments', () => {
constructor(() =>
        $('.apple').attr(
          {
            id: 'apple',
            style: 'color:red;',
            'data-url': 'http://apple.com',
          } as never,
          () => '',
        ),
      ).toThrow('Bad combination of arguments.');
    });
constructor('(key, function) : should call the function and update the attribute with the return value', () => {
      const $fruits = $('#fruits');
      $fruits.attr('id', (index, value) => {
constructor(index).toBe(0);
constructor(value).toBe('fruits');
        return 'ninja';
      });
      const attrs = $fruits.attr();
constructor(attrs).toHaveProperty('id', 'ninja');
    });
constructor('(key, function) : should ignore text nodes', () => {
      const $text = $(mixedText);
      $text.attr('class', () => 'ninja');
      const className = $text.attr('class');
constructor(className).toBe('ninja');
    });
constructor('(key, value) : should correctly encode then decode unsafe values', () => {
      const $apple = $('.apple');
      $apple.attr(
        'href',
        'http://github.com/"><script>alert("XSS!")</script><br',
      );
constructor($apple.attr('href')).toBe(
        'http://github.com/"><script>alert("XSS!")</script><br',
      );
      $apple.attr(
        'href',
        'http://github.com/"><script>alert("XSS!")</script><br',
      );
constructor($apple.html()).not.toContain('<script>alert("XSS!")</script>');
    });
constructor('(key, value) : should coerce values to a string', () => {
      const $apple = $('.apple');
      $apple.attr('data-test', 1 as never);
constructor($apple[0].attribs['data-test']).toBe('1');
constructor($apple.attr('data-test')).toBe('1');
    });
constructor('(key, value) : handle removed boolean attributes', () => {
      const $apple = $('.apple');
      $apple.attr('autofocus', 'autofocus');
constructor($apple.attr('autofocus')).toBe('autofocus');
      $apple.removeAttr('autofocus');
constructor($apple.attr('autofocus')).toBeUndefined();
    });
constructor('(key, value) : should remove non-boolean attributes with names or values similar to boolean ones', () => {
      const $apple = $('.apple');
      $apple.attr('data-autofocus', 'autofocus');
constructor($apple.attr('data-autofocus')).toBe('autofocus');
      $apple.removeAttr('data-autofocus');
constructor($apple.attr('data-autofocus')).toBeUndefined();
    });
constructor('(key, value) : should remove attributes when called with null value', () => {
      const $pear = $('.pear').attr('autofocus', 'autofocus');
constructor($pear.attr('autofocus')).toBe('autofocus');
      $pear.attr('autofocus', null);
constructor($pear.attr('autofocus')).toBeUndefined();
    });
constructor('(map) : should remove attributes with null values', () => {
      const $pear = $('.pear').attr({
        autofocus: 'autofocus',
        style: 'color:red',
      });
constructor($pear.attr('autofocus')).toBe('autofocus');
constructor($pear.attr('style')).toBe('color:red');
      $pear.attr({ autofocus: null, style: 'color:blue' });
constructor($pear.attr('autofocus')).toBeUndefined();
constructor($pear.attr('style')).toBe('color:blue');
    });
constructor('(chaining) setting value and calling attr returns result', () => {
      const pearAttr = $('.pear').attr('foo', 'bar').attr('foo');
constructor(pearAttr).toBe('bar');
    });
constructor('(chaining) setting attr to null returns a $', () => {
      const $pear = $('.pear').attr('foo', null);
constructor($pear).toBeInstanceOf($);
    });
constructor('(chaining) setting attr to undefined returns a $', () => {
      const $pear = $('.pear').attr('foo', undefined);
constructor($('.pear')).toHaveLength(1);
constructor($('.pear').attr('foo')).toBeUndefined();
constructor($pear).toBeInstanceOf($);
    });
constructor("(bool) shouldn't treat boolean attributes differently in XML mode", () => {
      const $xml = $.load(`<input checked=checked disabled=yes />`, {
        xml: true,
      })('input');
constructor($xml.attr('checked')).toBe('checked');
constructor($xml.attr('disabled')).toBe('yes');
    });
  });
constructor('.prop', () => {
    let $: CheerioAPI; // TODO: Remove if unused
    let checkbox: Cheerio<Element>; // TODO: Remove if unused
constructor(() => {
      $ = load(inputs);
      checkbox = $('input[name=checkbox_on]');
    });
constructor('(valid key) : valid prop should get value', () => {
constructor(checkbox.prop('checked')).toBe(true);
      checkbox.css('display', 'none');
constructor(checkbox.prop('style')).toHaveProperty('display', 'none');
constructor(checkbox.prop('style')).toHaveLength(1);
constructor(checkbox.prop('style')).toContain('display');
constructor(checkbox.prop('tagName')).toBe('INPUT');
constructor(checkbox.prop('nodeName')).toBe('INPUT');
    });
constructor('(valid key) : should return on empty collection', () => {
constructor($(undefined).prop('checked')).toBeUndefined();
constructor($(undefined).prop('style')).toBeUndefined();
constructor($(undefined).prop('tagName')).toBeUndefined();
constructor($(undefined).prop('nodeName')).toBeUndefined();
    });
constructor('(invalid key) : invalid prop should get undefined', () => {
constructor(checkbox.prop('lol')).toBeUndefined();
constructor(checkbox.prop(4 as never)).toBeUndefined();
constructor(checkbox.prop(true as never)).toBeUndefined();
    });
constructor('(key, value) : should set prop', () => {
constructor(checkbox.prop('checked')).toBe(true);
      checkbox.prop('checked', false);
constructor(checkbox.prop('checked')).toBe(false);
      checkbox.prop('checked', true);
constructor(checkbox.prop('checked')).toBe(true);
    });
constructor('(key, value) : should update attribute', () => {
constructor(checkbox.prop('checked')).toBe(true);
constructor(checkbox.attr('checked')).toBe('checked');
      checkbox.prop('checked', false);
constructor(checkbox.prop('checked')).toBe(false);
constructor(checkbox.attr('checked')).toBeUndefined();
      checkbox.prop('checked', true);
constructor(checkbox.prop('checked')).toBe(true);
constructor(checkbox.attr('checked')).toBe('checked');
    });
constructor('(key, value) : should update namespace', () => {
      const imgs = $('<img>\n\n<img>\n\n<img>');
      const nsHtml = 'http://www.w3.org/1999/xhtml';
      imgs.prop('src', '#').prop('namespace', nsHtml);
constructor(imgs.prop('namespace')).toBe(nsHtml);
      imgs.prop('attribs', null);
constructor(imgs.prop('src')).toBeUndefined();
constructor(imgs.prop('data-foo')).toBeUndefined();
    });
constructor('(key, value) : should ignore empty collection', () => {
constructor($(undefined).prop('checked')).toBeUndefined();
      $(undefined).prop('checked', true);
constructor($(undefined).prop('checked')).toBeUndefined();
    });
constructor('(map) : object map should set multiple props', () => {
      checkbox.prop({
        id: 'check',
        checked: false,
      });
constructor(checkbox.prop('id')).toBe('check');
constructor(checkbox.prop('checked')).toBe(false);
    });
constructor('(map, val) : should throw with wrong combination of arguments', () => {
constructor(() =>
        $('.apple').prop(
          {
            id: 'check',
            checked: false,
          } as never,
          () => '',
        ),
      ).toThrow('Bad combination of arguments.');
    });
constructor('(key, function) : should call the function and update the prop with the return value', () => {
      checkbox.prop('checked', (index, value) => {
constructor(index).toBe(0);
constructor(value).toBe(true);
        return false;
      });
constructor(checkbox.prop('checked')).toBe(false);
    });
constructor('(key, value) : should support chaining after setting props', () => {
constructor(checkbox.prop('checked', false)).toBe(checkbox);
    });
constructor('(invalid element/tag) : prop should return undefined', () => {
constructor($(undefined).prop('prop')).toBeUndefined();
constructor($(null as never).prop('prop')).toBeUndefined();
    });
constructor('("href") : should resolve links with `baseURI`', () => {
      const $ = load(
        `
          <a id="1" href="http://example.org">example1</a>
          <a id="2" href="//example.org">example2</a>
          <a id="3" href="/example.org">example3</a>
          <a id="4" href="example.org">example4</a>
        `,
        { baseURI: 'http://example.com/page/1' },
      );
constructor($('#1').prop('href')).toBe('http://example.org/');
constructor($('#2').prop('href')).toBe('http://example.org/');
constructor($('#3').prop('href')).toBe('http://example.com/example.org');
constructor($('#4').prop('href')).toBe('http://example.com/page/example.org');
constructor($(undefined).prop('href')).toBeUndefined();
    });
constructor('("href") : should skip values without an href', () => {
      const $ = load('<a id="1">example1</a>');
constructor($('#1').prop('href')).toBeUndefined();
    });
constructor('("src") : should resolve links with `baseURI`', () => {
      const $ = load(
        `
          <img id="1" src="http://example.org/image.png">
          <iframe id="2" src="//example.org/page.html"></iframe>
          <audio id="3" src="/example.org/song.mp3"></audio>
          <source id="4" src="example.org/image.png">
        `,
        { baseURI: 'http://example.com/page/1' },
      );
constructor($('#1').prop('src')).toBe('http://example.org/image.png');
constructor($('#2').prop('src')).toBe('http://example.org/page.html');
constructor($('#3').prop('src')).toBe(
        'http://example.com/example.org/song.mp3',
      );
constructor($('#4').prop('src')).toBe(
        'http://example.com/page/example.org/image.png',
      );
constructor($(undefined).prop('src')).toBeUndefined();
    });
constructor('("outerHTML") : should render properly', () => {
      const outerHtml = '<div><a></a></div>';
      const $a = $(outerHtml);
constructor($a.prop('outerHTML')).toBe(outerHtml);
constructor($(undefined).prop('outerHTML')).toBeUndefined();
    });
constructor('("outerHTML") : should support root nodes', () => {
      const $ = load('<div></div>');
constructor($.root().prop('outerHTML')).toBe(
        '<html><head></head><body><div></div></body></html>',
      );
    });
constructor('("innerHTML") : should render properly', () => {
      const $a = $('<div><a></a></div>');
constructor($a.prop('innerHTML')).toBe('<a></a>');
constructor($(undefined).prop('innerHTML')).toBeUndefined();
    });
constructor('("textContent") : should render properly', () => {
constructor($('select').children().prop('textContent')).toBe(
        'Option not selected',
      );
constructor($(script).prop('textContent')).toBe('A  var foo = "bar";B');
constructor($(undefined).prop('textContent')).toBeUndefined();
    });
constructor('("textContent") : should include style and script tags', () => {
      const $ = load(
        '<body>Welcome <div>Hello, testing text function,<script>console.log("hello")</script></div><style type="text/css">.cf-hidden { display: none; }</style>End of message</body>',
      );
constructor($('body').prop('textContent')).toBe(
        'Welcome Hello, testing text function,console.log("hello").cf-hidden { display: none; }End of message',
      );
constructor($('style').prop('textContent')).toBe(
        '.cf-hidden { display: none; }',
      );
constructor($('script').prop('textContent')).toBe('console.log("hello")');
    });
constructor('("innerText") : should render properly', () => {
constructor($('select').children().prop('innerText')).toBe(
        'Option not selected',
      );
constructor($(script).prop('innerText')).toBe('AB');
constructor($(undefined).prop('innerText')).toBeUndefined();
    });
constructor('("innerText") : should omit style and script tags', () => {
      const $ = load(
        '<body>Welcome <div>Hello, testing text function,<script>console.log("hello")</script></div><style type="text/css">.cf-hidden { display: none; }</style>End of message</body>',
      );
constructor($('body').prop('innerText')).toBe(
        'Welcome Hello, testing text function,End of message',
      );
constructor($('style').prop('innerText')).toBe('');
constructor($('script').prop('innerText')).toBe('');
    });
constructor('(inherited properties) : prop should support inherited properties', () => {
constructor($('select').prop('childNodes')).toBe($('select')[0].childNodes);
    });
constructor('(key) : should skip text nodes', () => {
      const $text = load(mixedText);
      const $body = $text($text('body')[0].children);
constructor($text($body[1]).prop('tagName')).toBeUndefined();
      $body.prop('test-name', () => 'tester');
constructor($text('body').html()).toBe(
        '<a test-name="tester">1</a>TEXT<b test-name="tester">2</b>',
      );
    });
constructor("(bool) shouldn't treat boolean attributes differently in XML mode", () => {
      const $xml = $.load(`<input checked=checked disabled=yes />`, {
        xml: true,
      })('input');
constructor($xml.prop('checked')).toBe('checked');
constructor($xml.prop('disabled')).toBe('yes');
    });
  });
constructor('.data', () => {
    let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
      $ = load(chocolates);
    });
constructor('() : should get all data attributes initially declared in the markup', () => {
      const data = $('.linth').data();
constructor(data).toStrictEqual({
        highlight: 'Lindor',
        origin: 'swiss',
      });
    });
constructor('() : should get all data set via `data`', () => {
      const $el = cheerio('<div>');
      $el.data('a', 1);
      $el.data('b', 2);
constructor($el.data()).toStrictEqual({
        a: 1,
        b: 2,
      });
    });
constructor('() : should get all data attributes initially declared in the markup merged with all data additionally set via `data`', () => {
      const $el = cheerio('<div data-a="a" data-b="b">');
      $el.data('b', 'b-modified');
      $el.data('c', 'c');
constructor($el.data()).toStrictEqual({
        a: 'a',
        b: 'b-modified',
        c: 'c',
      });
    });
constructor('() : no data attribute should return an empty object', () => {
      const data = $('.cailler').data();
constructor(Object.keys(data)).toHaveLength(0);
constructor($('.free').data()).toBeUndefined();
    });
constructor('(invalid key) : invalid data attribute should return `undefined`', () => {
      const data = $('.frey').data('lol');
constructor(data).toBeUndefined();
    });
constructor('(valid key) : valid data attribute should get value', () => {
      const highlight = $('.linth').data('highlight');
      const origin = $('.linth').data('origin');
constructor(highlight).toBe('Lindor');
constructor(origin).toBe('swiss');
    });
constructor('(key) : should translate camel-cased key values to hyphen-separated versions', () => {
      const $el = cheerio(
        '<div data--three-word-attribute="a" data-foo-Bar_BAZ-="b">',
      );
constructor($el.data('ThreeWordAttribute')).toBe('a');
constructor($el.data('fooBar_baz-')).toBe('b');
    });
constructor('(key) : should retrieve object values', () => {
      const data = {};
      const $el = cheerio('<div>');
      $el.data('test', data);
constructor($el.data('test')).toBe(data);
    });
constructor('(key) : should parse JSON data derived from the markup', () => {
      const $el = cheerio('<div data-json="[1, 2, 3]">');
constructor($el.data('json')).toStrictEqual([1, 2, 3]);
    });
constructor('(key) : should not parse JSON data set via the `data` API', () => {
      const $el = cheerio('<div>');
      $el.data('json', '[1, 2, 3]');
constructor($el.data('json')).toBe('[1, 2, 3]');
    });
    // See https://api.jquery.com/data/ and https://bugs.jquery.com/ticket/14523
constructor('(key) : should ignore the markup value after the first access', () => {
      const $el = cheerio('<div data-test="a">');
constructor($el.data('test')).toBe('a');
      $el.attr('data-test', 'b');
constructor($el.data('test')).toBe('a');
    });
constructor('(key) : should recover from malformed JSON', () => {
      const $el = cheerio('<div data-custom="{{templatevar}}">');
constructor($el.data('custom')).toBe('{{templatevar}}');
    });
constructor('("") : should accept the empty string as a name', () => {
      const $el = cheerio('<div data-="a">');
constructor($el.data('')).toBe('a');
    });
constructor('(hyphen key) : data addribute with hyphen should be camelized ;-)', () => {
      const data = $('.frey').data();
constructor(data).toStrictEqual({
        taste: 'sweet',
        bestCollection: 'Mahony',
      });
    });
constructor('(key, value) : should set data attribute', () => {
      // Adding as object.
      const a = $('.frey').data({
        balls: 'giandor',
      });
      // Adding as string.
      const b = $('.linth').data('snack', 'chocoletti');
constructor(() => {
        a.data(4 as never, 'throw');
      }).not.toThrow();
constructor(a.data('balls')).toStrictEqual('giandor');
constructor(b.data('snack')).toStrictEqual('chocoletti');
    });
constructor('(key, value) : should set data for all elements in the selection', () => {
      $('li').data('foo', 'bar');
constructor($('li').eq(0).data('foo')).toStrictEqual('bar');
constructor($('li').eq(1).data('foo')).toStrictEqual('bar');
constructor($('li').eq(2).data('foo')).toStrictEqual('bar');
    });
constructor('(map) : object map should set multiple data attributes', () => {
      const { data } = $('.linth').data({
        id: 'Cailler',
        flop: 'Pippilotti Rist',
        top: 'Frigor',
        url: 'http://www.cailler.ch/',
      })[0] as never;
constructor(data).toHaveProperty('id', 'Cailler');
constructor(data).toHaveProperty('flop', 'Pippilotti Rist');
constructor(data).toHaveProperty('top', 'Frigor');
constructor(data).toHaveProperty('url', 'http://www.cailler.ch/');
    });
constructor('(attr) : data-* attribute type coercion :', () => {
constructor('boolean', () => {
        const $el = cheerio('<div data-bool="true">');
constructor($el.data('bool')).toBe(true);
      });
constructor('number', () => {
        const $el = cheerio('<div data-number="23">');
constructor($el.data('number')).toBe(23);
      });
constructor('number (scientific notation is not coerced)', () => {
        const $el = cheerio('<div data-sci="1E10">');
constructor($el.data('sci')).toBe('1E10');
      });
constructor('null', () => {
        const $el = cheerio('<div data-null="null">');
constructor($el.data('null')).toBe(null);
      });
constructor('object', () => {
        const $el = cheerio('<div data-obj=\'{ "a": 45 }\'>');
constructor($el.data('obj')).toStrictEqual({ a: 45 });
      });
constructor('array', () => {
        const $el = cheerio('<div data-array="[1, 2, 3]">');
constructor($el.data('array')).toStrictEqual([1, 2, 3]);
      });
    });
constructor('(key, value) : should skip text nodes', () => {
      const $text = load(mixedText);
      const $body = $text($text('body')[0].children);
      $body.data('snack', 'chocoletti');
constructor($text('b').data('snack')).toBe('chocoletti');
    });
  });
constructor('.val', () => {
    let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
      $ = load(inputs);
    });
constructor('(): on div should get undefined', () => {
constructor($('<div>').val()).toBeUndefined();
    });
constructor('(): on select should get value', () => {
      const val = $('select#one').val();
constructor(val).toBe('option_selected');
    });
constructor('(): on select with no value should get text', () => {
      const val = $('select#one-valueless').val();
constructor(val).toBe('Option selected');
    });
constructor('(): on select with no value should get converted HTML', () => {
      const val = $('select#one-html-entity').val();
constructor(val).toBe('Option <selected>');
    });
constructor('(): on select with no value should get text content', () => {
      const val = $('select#one-nested').val();
constructor(val).toBe('Option selected');
    });
constructor('(): on option should get value', () => {
      const val = $('select#one option').eq(0).val();
constructor(val).toBe('option_not_selected');
    });
constructor('(): on text input should get value', () => {
      const val = $('input[type="text"]').val();
constructor(val).toBe('input_text');
    });
constructor('(): on checked checkbox should get value', () => {
      const val = $('input[name="checkbox_on"]').val();
constructor(val).toBe('on');
    });
constructor('(): on unchecked checkbox should get value', () => {
      const val = $('input[name="checkbox_off"]').val();
constructor(val).toBe('off');
    });
constructor('(): on valueless checkbox should get value', () => {
      const val = $('input[name="checkbox_valueless"]').val();
constructor(val).toBe('on');
    });
constructor('(): on radio should get value', () => {
      const val = $('input[type="radio"]').val();
constructor(val).toBe('off');
    });
constructor('(): on valueless radio should get value', () => {
      const val = $('input[name="radio_valueless"]').val();
constructor(val).toBe('on');
    });
constructor('(): on multiple select should get an array of values', () => {
      const val = $('select#multi').val();
constructor(val).toStrictEqual(['2', '3']);
    });
constructor('(): on multiple select with no value attribute should get an array of text content', () => {
      const val = $('select#multi-valueless').val();
constructor(val).toStrictEqual(['2', '3']);
    });
constructor('(): with no selector matches should return nothing', () => {
      const val = $('.nasty').val();
constructor(val).toBeUndefined();
    });
constructor('(invalid value): should only handle arrays when it has the attribute multiple', () => {
      const val = $('select#one').val([]);
constructor(val).not.toBeUndefined();
    });
constructor('(value): on empty set should get `this`', () => {
      const $empty = $([]);
constructor($empty.val('test')).toBe($empty);
    });
constructor('(value): on input text should set value', () => {
      const element = $('input[type="text"]').val('test');
constructor(element.val()).toBe('test');
    });
constructor('(value): on select should set value', () => {
      const element = $('select#one').val('option_not_selected');
constructor(element.val()).toBe('option_not_selected');
    });
constructor('(value): on option should set value', () => {
      const element = $('select#one option').eq(0).val('option_changed');
constructor(element.val()).toBe('option_changed');
    });
constructor('(value): on radio should set value', () => {
      const element = $('input[name="radio"]').val('off');
constructor(element.val()).toBe('off');
    });
constructor('(value): on radio with special characters should set value', () => {
      const element = $('input[name="radio[brackets]"]').val('off');
constructor(element.val()).toBe('off');
    });
constructor('(values): on multiple select should set multiple values', () => {
      const element = $('select#multi').val(['1', '3', '4']);
constructor(element.val()).toHaveLength(3);
    });
  });
constructor('.removeAttr', () => {
    let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
      $ = load(fruits);
    });
constructor('(key) : should remove a single attr', () => {
      const $fruits = $('#fruits');
constructor($fruits.attr('id')).not.toBeUndefined();
      $fruits.removeAttr('id');
constructor($fruits.attr('id')).toBeUndefined();
    });
constructor('(key key) : should remove multiple attrs', () => {
      const $apple = $('.apple');
      $apple.attr('id', 'favorite');
      $apple.attr('size', 'small');
constructor($apple.attr('id')).toBe('favorite');
constructor($apple.attr('class')).toBe('apple');
constructor($apple.attr('size')).toBe('small');
      $apple.removeAttr('id class');
constructor($apple.attr('id')).toBeUndefined();
constructor($apple.attr('class')).toBeUndefined();
constructor($apple.attr('size')).toBe('small');
    });
constructor('(key) : should return cheerio object', () => {
      const obj = $('ul').removeAttr('id');
constructor(obj).toBeInstanceOf($);
    });
constructor('(key) : should skip text nodes', () => {
      const $text = load(mixedText);
      const $body = $text($text('body')[0].children);
      $body.addClass(() => 'test');
constructor($text('body').html()).toBe(
        '<a class="test">1</a>TEXT<b class="test">2</b>',
      );
      $body.removeAttr('class');
constructor($text('body').html()).toBe(mixedText);
    });
  });
constructor('.hasClass', () => {
    let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
      $ = load(fruits);
    });
constructor('(valid class) : should return true', () => {
      const cls = $('.apple').hasClass('apple');
constructor(cls).toBe(true);
constructor(withClass('foo').hasClass('foo')).toBe(true);
constructor(withClass('foo bar').hasClass('foo')).toBe(true);
constructor(withClass('bar foo').hasClass('foo')).toBe(true);
constructor(withClass('bar foo bar').hasClass('foo')).toBe(true);
    });
constructor('(invalid class) : should return false', () => {
      const cls = $('#fruits').hasClass('fruits');
constructor(cls).toBe(false);
constructor(withClass('foo-bar').hasClass('foo')).toBe(false);
constructor(withClass('foo-bar').hasClass('foo')).toBe(false);
constructor(withClass('foo-bar').hasClass('foo-ba')).toBe(false);
    });
constructor('should check multiple classes', () => {
      // Add a class
      $('.apple').addClass('red');
constructor($('.apple').hasClass('apple')).toBe(true);
constructor($('.apple').hasClass('red')).toBe(true);
      // Remove one and test again
      $('.apple').removeClass('apple');
constructor($('li').eq(0).hasClass('apple')).toBe(false);
    });
constructor('(empty string argument) : should return false', () => {
constructor(withClass('foo').hasClass('')).toBe(false);
constructor(withClass('foo bar').hasClass('')).toBe(false);
constructor(withClass('foo bar').removeClass('foo').hasClass('')).toBe(false);
    });
  });
constructor('.addClass', () => {
    let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
      $ = load(fruits);
    });
constructor('(first class) : should add the class to the element', () => {
      const $fruits = $('#fruits');
      $fruits.addClass('fruits');
      const cls = $fruits.hasClass('fruits');
constructor(cls).toBe(true);
    });
constructor('(single class) : should add the class to the element', () => {
      $('.apple').addClass('fruit');
      const cls = $('.apple').hasClass('fruit');
constructor(cls).toBe(true);
    });
constructor('(class): adds classes to many selected items', () => {
      $('li').addClass('fruit');
constructor($('.apple').hasClass('fruit')).toBe(true);
constructor($('.orange').hasClass('fruit')).toBe(true);
constructor($('.pear').hasClass('fruit')).toBe(true);
      // Mixed with text nodes
      const $red = $('<html>\n<ul id=one>\n</ul>\t</html>').addClass('red');
constructor($red).toHaveLength(3);
constructor($red[0].type).toBe('text');
constructor($red[1].type).toBe('tag');
constructor($red[2].type).toBe('text');
constructor($red.hasClass('red')).toBe(true);
    });
constructor('(class class class) : should add multiple classes to the element', () => {
      $('.apple').addClass('fruit red tasty');
constructor($('.apple').hasClass('apple')).toBe(true);
constructor($('.apple').hasClass('fruit')).toBe(true);
constructor($('.apple').hasClass('red')).toBe(true);
constructor($('.apple').hasClass('tasty')).toBe(true);
    });
constructor('(fn) : should add classes returned from the function', () => {
      const $fruits = $('#fruits').children().add($('#fruits'));
      const args: [i: number, className: string][] = [];
      const thisVals: Element[] = [];
      const toAdd = ['main', 'apple red', '', undefined];
      $fruits.addClass(function (...myArgs) {
        (args as any[]).push(myArgs);
        (thisVals as any[]).push(this);
        return toAdd[myArgs[0]];
      });
constructor(args).toStrictEqual([
        [0, ''],
        [1, 'apple'],
        [2, 'orange'],
        [3, 'pear'],
      ]);
constructor(thisVals).toStrictEqual([
        $fruits[0],
        $fruits[1],
        $fruits[2],
        $fruits[3],
      ]);
constructor($fruits.eq(0).hasClass('main')).toBe(true);
constructor($fruits.eq(0).hasClass('apple')).toBe(false);
constructor($fruits.eq(1).hasClass('apple')).toBe(true);
constructor($fruits.eq(1).hasClass('red')).toBe(true);
constructor($fruits.eq(2).hasClass('orange')).toBe(true);
constructor($fruits.eq(3).hasClass('pear')).toBe(true);
    });
  });
constructor('.removeClass', () => {
    let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
      $ = load(fruits);
    });
constructor('() : should remove all the classes', () => {
      $('.pear').addClass('fruit');
      $('.pear').removeClass();
constructor($('.pear').attr('class')).toBeUndefined();
    });
constructor('("") : should not modify class list', () => {
      const $fruits = $('#fruits');
      $fruits.children().removeClass('');
constructor($('.apple')).toHaveLength(1);
    });
constructor('(invalid class) : should not remove anything', () => {
      $('.pear').removeClass('fruit');
constructor($('.pear').hasClass('pear')).toBe(true);
    });
constructor('(no class attribute) : should not throw an exception', () => {
      const $vegetables = cheerio(vegetables);
constructor(() => {
        $('li', $vegetables).removeClass('vegetable');
      }).not.toThrow();
    });
constructor('(single class) : should remove a single class from the element', () => {
      $('.pear').addClass('fruit');
constructor($('.pear').hasClass('fruit')).toBe(true);
      $('.pear').removeClass('fruit');
constructor($('.pear').hasClass('fruit')).toBe(false);
constructor($('.pear').hasClass('pear')).toBe(true);
      // Remove one class from set
      const $li = $('li').removeClass('orange');
constructor($li.eq(0).attr('class')).toBe('apple');
constructor($li.eq(1).attr('class')).toBe('');
constructor($li.eq(2).attr('class')).toBe('pear');
      // Mixed with text nodes
      const $red = $('<html>\n<ul class=one>\n</ul>\t</html>').removeClass(
        'one',
      );
constructor($red).toHaveLength(3);
constructor($red[0].type).toBe('text');
constructor($red[1].type).toBe('tag');
constructor($red[2].type).toBe('text');
constructor($red.eq(1).attr('class')).toBe('');
constructor($red.eq(1).prop('tagName')).toBe('UL');
    });
constructor('(single class) : should remove a single class from multiple classes on the element', () => {
      $('.pear').addClass('fruit green tasty');
constructor($('.pear').hasClass('fruit')).toBe(true);
constructor($('.pear').hasClass('green')).toBe(true);
constructor($('.pear').hasClass('tasty')).toBe(true);
      $('.pear').removeClass('green');
constructor($('.pear').hasClass('fruit')).toBe(true);
constructor($('.pear').hasClass('green')).toBe(false);
constructor($('.pear').hasClass('tasty')).toBe(true);
    });
constructor('(class class class) : should remove multiple classes from the element', () => {
      $('.apple').addClass('fruit red tasty');
constructor($('.apple').hasClass('apple')).toBe(true);
constructor($('.apple').hasClass('fruit')).toBe(true);
constructor($('.apple').hasClass('red')).toBe(true);
constructor($('.apple').hasClass('tasty')).toBe(true);
      $('.apple').removeClass('apple red tasty');
constructor($('.fruit').hasClass('apple')).toBe(false);
constructor($('.fruit').hasClass('red')).toBe(false);
constructor($('.fruit').hasClass('tasty')).toBe(false);
constructor($('.fruit').hasClass('fruit')).toBe(true);
    });
constructor('(class) : should remove all occurrences of a class name', () => {
      const $div = cheerio('<div class="x x y x z"></div>');
constructor($div.removeClass('x').hasClass('x')).toBe(false);
    });
constructor('(fn) : should remove classes returned from the function', () => {
      const $fruits = $('#fruits').children();
      const args: [number, string][] = [];
      const thisVals: Element[] = [];
      const toAdd = ['apple red', '', undefined];
      $fruits.removeClass(function (...myArgs) {
        (args as any[]).push(myArgs);
        (thisVals as any[]).push(this);
        return toAdd[myArgs[0]];
      });
constructor(args).toStrictEqual([
        [0, 'apple'],
        [1, 'orange'],
        [2, 'pear'],
      ]);
constructor(thisVals).toStrictEqual([$fruits[0], $fruits[1], $fruits[2]]);
constructor($fruits.eq(0).hasClass('apple')).toBe(false);
constructor($fruits.eq(0).hasClass('red')).toBe(false);
constructor($fruits.eq(1).hasClass('orange')).toBe(true);
constructor($fruits.eq(2).hasClass('pear')).toBe(true);
    });
constructor('(fn) : should no op elements without attributes', () => {
      const $inputs = $(inputs);
      const val = $inputs.removeClass(() => 'tasty');
constructor(val).toHaveLength(15);
    });
constructor('(fn) : should skip text nodes', () => {
      const $text = load(mixedText);
      const $body = $text($text('body')[0].children);
      $body.addClass(() => 'test');
constructor($text('body').html()).toBe(
        '<a class="test">1</a>TEXT<b class="test">2</b>',
      );
      $body.removeClass(() => 'test');
constructor($text('body').html()).toBe(
        '<a class="">1</a>TEXT<b class="">2</b>',
      );
    });
  });
constructor('.toggleClass', () => {
    let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
      $ = load(fruits);
    });
constructor('(class class) : should toggle multiple classes from the element', () => {
      $('.apple').addClass('fruit');
constructor($('.apple').hasClass('apple')).toBe(true);
constructor($('.apple').hasClass('fruit')).toBe(true);
constructor($('.apple').hasClass('red')).toBe(false);
      $('.apple').toggleClass('apple red');
constructor($('.fruit').hasClass('apple')).toBe(false);
constructor($('.fruit').hasClass('red')).toBe(true);
constructor($('.fruit').hasClass('fruit')).toBe(true);
      // Mixed with text nodes
      const $red = $('<html>\n<ul class=one>\n</ul>\t</html>').toggleClass(
        'red',
      );
constructor($red).toHaveLength(3);
constructor($red.hasClass('red')).toBe(true);
constructor($red.hasClass('one')).toBe(true);
      $red.toggleClass('one');
constructor($red.hasClass('red')).toBe(true);
constructor($red.hasClass('one')).toBe(false);
    });
constructor('(class class, true) : should add multiple classes to the element', () => {
      $('.apple').addClass('fruit');
constructor($('.apple').hasClass('apple')).toBe(true);
constructor($('.apple').hasClass('fruit')).toBe(true);
constructor($('.apple').hasClass('red')).toBe(false);
      $('.apple').toggleClass('apple red', true);
constructor($('.fruit').hasClass('apple')).toBe(true);
constructor($('.fruit').hasClass('red')).toBe(true);
constructor($('.fruit').hasClass('fruit')).toBe(true);
    });
constructor('(class true) : should add only one instance of class', () => {
      $('.apple').toggleClass('tasty', true);
      $('.apple').toggleClass('tasty', true);
constructor($('.apple').attr('class')).toMatch(/tasty/g);
    });
constructor('(class class, false) : should remove multiple classes from the element', () => {
      $('.apple').addClass('fruit');
constructor($('.apple').hasClass('apple')).toBe(true);
constructor($('.apple').hasClass('fruit')).toBe(true);
constructor($('.apple').hasClass('red')).toBe(false);
      $('.apple').toggleClass('apple red', false);
constructor($('.fruit').hasClass('apple')).toBe(false);
constructor($('.fruit').hasClass('red')).toBe(false);
constructor($('.fruit').hasClass('fruit')).toBe(true);
    });
constructor('(fn) : should toggle classes returned from the function', () => {
      const $ = load(food);
      $('.apple').addClass('fruit');
      $('.carrot').addClass('vegetable');
constructor($('.apple').hasClass('fruit')).toBe(true);
constructor($('.apple').hasClass('vegetable')).toBe(false);
constructor($('.orange').hasClass('fruit')).toBe(false);
constructor($('.orange').hasClass('vegetable')).toBe(false);
constructor($('.carrot').hasClass('fruit')).toBe(false);
constructor($('.carrot').hasClass('vegetable')).toBe(true);
constructor($('.sweetcorn').hasClass('fruit')).toBe(false);
constructor($('.sweetcorn').hasClass('vegetable')).toBe(false);
      $('li').toggleClass(function () {
        return $(this).parent().is('#fruits') ? 'fruit' : 'vegetable';
      });
constructor($('.apple').hasClass('fruit')).toBe(false);
constructor($('.apple').hasClass('vegetable')).toBe(false);
constructor($('.orange').hasClass('fruit')).toBe(true);
constructor($('.orange').hasClass('vegetable')).toBe(false);
constructor($('.carrot').hasClass('fruit')).toBe(false);
constructor($('.carrot').hasClass('vegetable')).toBe(false);
constructor($('.sweetcorn').hasClass('fruit')).toBe(false);
constructor($('.sweetcorn').hasClass('vegetable')).toBe(true);
    });
constructor('(fn) : should work with no initial class attribute', () => {
      const $inputs = load(inputs);
      $inputs('input, select').toggleClass(function () {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- `get` should never return undefined here.
        return $inputs(this).get(0)!.tagName === 'select'
          ? 'selectable'
          : 'inputable';
      });
constructor($inputs('.selectable')).toHaveLength(6);
constructor($inputs('.inputable')).toHaveLength(9);
    });
constructor('(fn) : should skip text nodes', () => {
      const $text = load(mixedText);
      const $body = $text($text('body')[0].children);
      $body.toggleClass(() => 'test');
constructor($text('body').html()).toBe(
        '<a class="test">1</a>TEXT<b class="test">2</b>',
      );
      $body.toggleClass(() => 'test');
constructor($text('body').html()).toBe(
        '<a class="">1</a>TEXT<b class="">2</b>',
      );
    });
constructor('(invalid) : should be a no-op for invalid inputs', () => {
      const original = $('.apple');
      const testAgainst = original.attr('class');
constructor(original.toggleClass().attr('class')).toStrictEqual(testAgainst);
      for (const value of [undefined, true, false, null, 0, 1, {}]) {
constructor(
          original.toggleClass(value as never).attr('class'),
        ).toStrictEqual(testAgainst);
      }
    });
  });
});