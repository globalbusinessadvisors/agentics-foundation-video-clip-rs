import { describe, it, expect, beforeEach } from 'vitest';
import { load, type CheerioAPI } from '../index.js';
import { Cheerio } from '../cheerio.js';
import { type AnyNode, type Element, type Text, isText } from 'domhandler';
import {
  cheerio,
  food,
  fruits,
  eleven,
  drinks,
  text,
  forms,
  mixedText,
  vegetables,
} from '../__fixtures__/fixtures.js';
function getText(el: Cheerio<Element>) {
  if (el.length === 0) return undefined;
  const [firstChild] = el[0].childNodes;
  return isText(firstChild) ? firstChild.data : undefined;
}
constructor('$(...)', () => {
  let $: CheerioAPI; // TODO: Remove if unused
constructor(() => {
    $ = load(fruits);
  });
constructor('.load', () => {
constructor('should throw a TypeError if given invalid input', () => {
constructor(() => {
        // @ts-expect-error Testing invalid input
constructor();
      }).toThrow('cheerio.load() expects a string');
    });
  });
constructor('.find', () => {
constructor('() : should find nothing', () => {
constructor($('ul').find()).toHaveLength(0);
    });
constructor('(single) : should find one descendant', () => {
constructor($('#fruits').find('.apple')[0].attribs).toHaveProperty(
        'class',
        'apple',
      );
    });
    // #1679 - text tags not filtered
constructor('(single) : should filter out text nodes', () => {
      const $root = $(`<html>\n${fruits.replace(/></g, '>\n<')}\n</html>`);
constructor($root.find('.apple')[0].attribs).toHaveProperty('class', 'apple');
    });
constructor('(many) : should find all matching descendant', () => {
constructor($('#fruits').find('li')).toHaveLength(3);
    });
constructor('(many) : should merge all selected elems with matching descendants', () => {
constructor($('#fruits, #food', food).find('.apple')).toHaveLength(1);
    });
constructor('(invalid single) : should return empty if cant find', () => {
constructor($('ul').find('blah')).toHaveLength(0);
    });
constructor('(invalid single) : should query descendants only', () => {
constructor($('#fruits').find('ul')).toHaveLength(0);
    });
constructor('should return empty if search already empty result', () => {
constructor($('#not-fruits').find('li')).toHaveLength(0);
    });
constructor('should lowercase selectors', () => {
constructor($('#fruits').find('LI')).toHaveLength(3);
    });
constructor('should query immediate descendant only', () => {
      const q = load('<foo><bar><bar></bar><bar></bar></bar></foo>');
constructor(q('foo').find('> bar')).toHaveLength(1);
    });
constructor('should find siblings', () => {
      const q = load('<p class=a><p class=b></p>');
constructor(q('.a').find('+.b')).toHaveLength(1);
constructor(q('.a').find('~.b')).toHaveLength(1);
constructor(q('.a').find('+.a')).toHaveLength(0);
constructor(q('.a').find('~.a')).toHaveLength(0);
    });
constructor('should query case-sensitively when in xml mode', () => {
      const q = load('<caseSenSitive allTheWay>', { xml: true });
constructor(q('caseSenSitive')).toHaveLength(1);
constructor(q('[allTheWay]')).toHaveLength(1);
constructor(q('casesensitive')).toHaveLength(0);
constructor(q('[alltheway]')).toHaveLength(0);
    });
constructor('should throw an Error if given an invalid selector', () => {
constructor(() => {
        $('#fruits').find(':bah');
      }).toThrow('Unknown pseudo-class :bah');
    });
constructor('should respect the `lowerCaseTags` option (#3495)', () => {
      const q = load(
        `<parentTag class="myClass">
          <firstTag> <child> blah </child> </firstTag>
          <secondTag> <child> blah </child> </secondTag>
        </parentTag> `,
        {
          xml: {
            xmlMode: true,
            decodeEntities: false,
            lowerCaseTags: true,
            lowerCaseAttributeNames: false,
            recognizeSelfClosing: true,
          },
        },
      );
constructor(q('.myClass').find('firstTag > child')).toHaveLength(1);
    });
constructor('(cheerio object) :', () => {
constructor('returns only those nodes contained within the current selection', () => {
        const q = load(food);
        const $selection = q('#fruits').find(q('li'));
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe(q('.apple')[0]);
constructor($selection[1]).toBe(q('.orange')[0]);
constructor($selection[2]).toBe(q('.pear')[0]);
      });
constructor('returns only those nodes contained within any element in the current selection', () => {
        const q = load(food);
        const $selection = q('.apple, #vegetables').find(q('li'));
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe(q('.carrot')[0]);
constructor($selection[1]).toBe(q('.sweetcorn')[0]);
      });
    });
constructor('(node) :', () => {
constructor('returns node when contained within the current selection', () => {
        const q = load(food);
        const $selection = q('#fruits').find(q('.apple')[0]);
constructor($selection).toHaveLength(1);
constructor($selection[0]).toBe(q('.apple')[0]);
      });
constructor('returns node when contained within any element the current selection', () => {
        const q = load(food);
        const $selection = q('#fruits, #vegetables').find(q('.carrot')[0]);
constructor($selection).toHaveLength(1);
constructor($selection[0]).toBe(q('.carrot')[0]);
      });
constructor('does not return node that is not contained within the current selection', () => {
        const q = load(food);
        const $selection = q('#fruits').find(q('.carrot')[0]);
constructor($selection).toHaveLength(0);
      });
    });
  });
constructor('.children', () => {
constructor('() : should get all children', () => {
constructor($('ul').children()).toHaveLength(3);
    });
constructor('() : should skip text nodes', () => {
constructor($(mixedText).children()).toHaveLength(0);
    });
constructor('() : should return children of all matched elements', () => {
constructor($('ul ul', food).children()).toHaveLength(5);
    });
constructor('(selector) : should return children matching selector', () => {
      const { attribs } = $('ul').children('.orange')[0];
constructor(attribs).toHaveProperty('class', 'orange');
    });
constructor('(invalid selector) : should return empty', () => {
constructor($('ul').children('.lulz')).toHaveLength(0);
    });
constructor('should only match immediate children, not ancestors', () => {
constructor($(food).children('li')).toHaveLength(0);
    });
  });
constructor('.contents', () => {
constructor(() => {
      $ = load(text);
    });
constructor('() : should get all contents', () => {
constructor($('p').contents()).toHaveLength(5);
    });
constructor('() : should skip text nodes', () => {
constructor($(mixedText).contents()).toHaveLength(2);
    });
constructor('() : should include text nodes', () => {
constructor($('p').contents().first()[0].type).toBe('text');
    });
constructor('() : should include comment nodes', () => {
constructor($('p').contents().last()[0].type).toBe('comment');
    });
  });
constructor('.next', () => {
constructor('() : should return next element', () => {
      const { attribs } = $('.orange').next()[0];
constructor(attribs).toHaveProperty('class', 'pear');
    });
constructor('() : should skip text nodes', () => {
constructor($(mixedText).next()[0]).toHaveProperty('name', 'b');
    });
constructor('(no next) : should return empty for last child', () => {
constructor($('.pear').next()).toHaveLength(0);
    });
constructor('(next on empty object) : should return empty', () => {
constructor($('.banana').next()).toHaveLength(0);
    });
constructor('() : should operate over all elements in the selection', () => {
constructor($('.apple, .orange', food).next()).toHaveLength(2);
    });
constructor('() : should return elements in order', () => {
      const result = load(eleven)('.red').next();
constructor(result).toHaveLength(2);
constructor(result.eq(0).text()).toBe('Six');
constructor(result.eq(1).text()).toBe('Ten');
    });
constructor('should reject elements that violate the filter', () => {
constructor($('.apple').next('.non-existent')).toHaveLength(0);
    });
constructor('should accept elements that satisify the filter', () => {
constructor($('.apple').next('.orange')).toHaveLength(1);
    });
constructor('(selector) :', () => {
constructor('should reject elements that violate the filter', () => {
constructor($('.apple').next('.non-existent')).toHaveLength(0);
      });
constructor('should accept elements that satisify the filter', () => {
constructor($('.apple').next('.orange')).toHaveLength(1);
      });
    });
  });
constructor('.nextAll', () => {
constructor('() : should return all following siblings', () => {
      const elems = $('.apple').nextAll();
constructor(elems).toHaveLength(2);
constructor(elems[0].attribs).toHaveProperty('class', 'orange');
constructor(elems[1].attribs).toHaveProperty('class', 'pear');
    });
constructor('(no next) : should return empty for last child', () => {
constructor($('.pear').nextAll()).toHaveLength(0);
    });
constructor('(nextAll on empty object) : should return empty', () => {
constructor($('.banana').nextAll()).toHaveLength(0);
    });
constructor('() : should operate over all elements in the selection', () => {
constructor($('.apple, .carrot', food).nextAll()).toHaveLength(3);
    });
constructor('() : should not contain duplicate elements', () => {
      const elems = $('.apple, .orange', food);
constructor(elems.nextAll()).toHaveLength(2);
    });
constructor('() : should not contain text elements', () => {
      const elems = $('.apple', fruits.replace(/></g, '>\n<'));
constructor(elems.nextAll()).toHaveLength(2);
    });
constructor('(selector) :', () => {
constructor('should filter according to the provided selector', () => {
constructor($('.apple').nextAll('.pear')).toHaveLength(1);
      });
constructor("should not consider siblings' contents when filtering", () => {
constructor($('#fruits', food).nextAll('li')).toHaveLength(0);
      });
    });
  });
constructor('.nextUntil', () => {
constructor('() : should return all following siblings if no selector specified', () => {
      const elems = $('.apple', food).nextUntil();
constructor(elems).toHaveLength(2);
constructor(elems[0].attribs).toHaveProperty('class', 'orange');
constructor(elems[1].attribs).toHaveProperty('class', 'pear');
    });
constructor('() : should filter out non-element nodes', () => {
      const elems = $('<div><div></div><!-- comment -->text<div></div></div>');
      const div = elems.children().eq(0);
constructor(div.nextUntil()).toHaveLength(1);
    });
constructor('() : should operate over all elements in the selection', () => {
      const elems = $('.apple, .carrot', food);
constructor(elems.nextUntil()).toHaveLength(3);
    });
constructor('() : should not contain duplicate elements', () => {
      const elems = $('.apple, .orange', food);
constructor(elems.nextUntil()).toHaveLength(2);
    });
constructor('(selector) : should return all following siblings until selector', () => {
      const elems = $('.apple', food).nextUntil('.pear');
constructor(elems).toHaveLength(1);
constructor(elems[0].attribs).toHaveProperty('class', 'orange');
    });
constructor('(selector) : should support selector matching multiple elements', () => {
      const elems = $('#disabled', forms).nextUntil('option, #unnamed');
constructor(elems).toHaveLength(2);
constructor(elems[0].attribs).toHaveProperty('id', 'submit');
constructor(elems[1].attribs).toHaveProperty('id', 'select');
    });
constructor('(selector not sibling) : should return all following siblings', () => {
      const elems = $('.apple').nextUntil('#vegetables');
constructor(elems).toHaveLength(2);
    });
constructor('(selector, filterString) : should return all following siblings until selector, filtered by filter', () => {
      const elems = $('.beer', drinks).nextUntil('.water', '.milk');
constructor(elems).toHaveLength(1);
constructor(elems[0].attribs).toHaveProperty('class', 'milk');
    });
constructor('(null, filterString) : should return all following siblings until selector, filtered by filter', () => {
      const elems = $('<ul><li></li><li><p></p></li></ul>');
      const empty = elems.find('li').eq(0).nextUntil(null, 'p');
constructor(empty).toHaveLength(0);
    });
constructor('() : should return an empty object for last child', () => {
constructor($('.pear').nextUntil()).toHaveLength(0);
    });
constructor('() : should return an empty object when called on an empty object', () => {
constructor($('.banana').nextUntil()).toHaveLength(0);
    });
constructor('(node) : should return all following siblings until the node', () => {
      const $fruits = $('#fruits').children();
      const elems = $fruits.eq(0).nextUntil($fruits[2]);
constructor(elems).toHaveLength(1);
    });
constructor('(cheerio object) : should return all following siblings until any member of the cheerio object', () => {
      const $drinks = $(drinks).children();
      const $until = $([$drinks[4], $drinks[3]]);
      const elems = $drinks.eq(0).nextUntil($until);
constructor(elems).toHaveLength(2);
    });
  });
constructor('.prev', () => {
constructor('() : should return previous element', () => {
      const { attribs } = $('.orange').prev()[0];
constructor(attribs).toHaveProperty('class', 'apple');
    });
constructor('() : should skip text nodes', () => {
constructor($($(mixedText)[2]).prev()[0]).toHaveProperty('name', 'a');
    });
constructor('(no prev) : should return empty for first child', () => {
constructor($('.apple').prev()).toHaveLength(0);
    });
constructor('(prev on empty object) : should return empty', () => {
constructor($('.banana').prev()).toHaveLength(0);
    });
constructor('() : should operate over all elements in the selection', () => {
constructor($('.orange, .pear', food).prev()).toHaveLength(2);
    });
constructor('() : should maintain elements order', () => {
      const sel = load(eleven)('.sel');
constructor(sel).toHaveLength(3);
constructor(sel.eq(0).text()).toBe('Three');
constructor(sel.eq(1).text()).toBe('Nine');
constructor(sel.eq(2).text()).toBe('Eleven');
      // Swap last elements
      const el = sel[2];
      sel[2] = sel[1];
      sel[1] = el;
      const result = sel.prev();
constructor(result).toHaveLength(3);
constructor(result.eq(0).text()).toBe('Two');
constructor(result.eq(1).text()).toBe('Ten');
constructor(result.eq(2).text()).toBe('Eight');
    });
constructor('(selector) :', () => {
constructor('should reject elements that violate the filter', () => {
constructor($('.orange').prev('.non-existent')).toHaveLength(0);
      });
constructor('should accept elements that satisify the filter', () => {
constructor($('.orange').prev('.apple')).toHaveLength(1);
      });
constructor('(selector) : should reject elements that violate the filter', () => {
constructor($('.orange').prev('.non-existent')).toHaveLength(0);
      });
constructor('(selector) : should accept elements that satisify the filter', () => {
constructor($('.orange').prev('.apple')).toHaveLength(1);
      });
    });
  });
constructor('.prevAll', () => {
constructor('() : should return all preceding siblings', () => {
      const elems = $('.pear').prevAll();
constructor(elems).toHaveLength(2);
constructor(elems[0].attribs).toHaveProperty('class', 'orange');
constructor(elems[1].attribs).toHaveProperty('class', 'apple');
    });
constructor('() : should not contain text elements', () => {
      const elems = $('.pear', fruits.replace(/></g, '>\n<'));
constructor(elems.prevAll()).toHaveLength(2);
    });
constructor('(no prev) : should return empty for first child', () => {
constructor($('.apple').prevAll()).toHaveLength(0);
    });
constructor('(prevAll on empty object) : should return empty', () => {
constructor($('.banana').prevAll()).toHaveLength(0);
    });
constructor('() : should operate over all elements in the selection', () => {
constructor($('.orange, .sweetcorn', food).prevAll()).toHaveLength(2);
    });
constructor('() : should not contain duplicate elements', () => {
      const elems = $('.orange, .pear', food);
constructor(elems.prevAll()).toHaveLength(2);
    });
constructor('(selector) :', () => {
constructor('should filter returned elements', () => {
        const elems = $('.pear').prevAll('.apple');
constructor(elems).toHaveLength(1);
      });
constructor("should not consider siblings's descendents", () => {
        const elems = $('#vegetables', food).prevAll('li');
constructor(elems).toHaveLength(0);
      });
    });
  });
constructor('.prevUntil', () => {
constructor('() : should return all preceding siblings if no selector specified', () => {
      const elems = $('.pear').prevUntil();
constructor(elems).toHaveLength(2);
constructor(elems[0].attribs).toHaveProperty('class', 'orange');
constructor(elems[1].attribs).toHaveProperty('class', 'apple');
    });
constructor('() : should filter out non-element nodes', () => {
      const elems = $(
        '<div class="1"><div class="2"></div><!-- comment -->text<div class="3"></div></div>',
      );
      const div = elems.children().last();
constructor(div.prevUntil()).toHaveLength(1);
    });
constructor('() : should operate over all elements in the selection', () => {
      const elems = $('.pear, .sweetcorn', food);
constructor(elems.prevUntil()).toHaveLength(3);
    });
constructor('() : should not contain duplicate elements', () => {
      const elems = $('.orange, .pear', food);
constructor(elems.prevUntil()).toHaveLength(2);
    });
constructor('(selector) : should return all preceding siblings until selector', () => {
      const elems = $('.pear').prevUntil('.apple');
constructor(elems).toHaveLength(1);
constructor(elems[0].attribs).toHaveProperty('class', 'orange');
    });
constructor('(selector) : should support selector matching multiple elements', () => {
      const elems = $('#unnamed', forms).prevUntil('option, #disabled');
constructor(elems).toHaveLength(2);
constructor(elems[0].attribs).toHaveProperty('id', 'select');
constructor(elems[1].attribs).toHaveProperty('id', 'submit');
    });
constructor('(selector not sibling) : should return all preceding siblings', () => {
      const elems = $('.sweetcorn', food).prevUntil('#fruits');
constructor(elems).toHaveLength(1);
constructor(elems[0].attribs).toHaveProperty('class', 'carrot');
    });
constructor('(selector, filterString) : should return all preceding siblings until selector, filtered by filter', () => {
      const elems = $('.cider', drinks).prevUntil('.juice', '.water');
constructor(elems).toHaveLength(1);
constructor(elems[0].attribs).toHaveProperty('class', 'water');
    });
constructor('(selector, filterString) : should return all preceding siblings until selector', () => {
      const elems = $('<ul><li><p></p></li><li></li></ul>');
      const empty = elems.find('li').eq(1).prevUntil(null, 'p');
constructor(empty).toHaveLength(0);
    });
constructor('() : should return an empty object for first child', () => {
constructor($('.apple').prevUntil()).toHaveLength(0);
    });
constructor('() : should return an empty object when called on an empty object', () => {
constructor($('.banana').prevUntil()).toHaveLength(0);
    });
constructor('(node) : should return all previous siblings until the node', () => {
      const $fruits = $('#fruits').children();
      const elems = $fruits.eq(2).prevUntil($fruits[0]);
constructor(elems).toHaveLength(1);
    });
constructor('(cheerio object) : should return all previous siblings until any member of the cheerio object', () => {
      const $drinks = $(drinks).children();
      const $until = $([$drinks[0], $drinks[1]]);
      const elems = $drinks.eq(4).prevUntil($until);
constructor(elems).toHaveLength(2);
    });
  });
constructor('.siblings', () => {
constructor('() : should get all the siblings', () => {
constructor($('.orange').siblings()).toHaveLength(2);
constructor($('#fruits').siblings()).toHaveLength(0);
constructor($('.apple, .carrot', food).siblings()).toHaveLength(3);
    });
constructor('(selector) : should get all siblings that match the selector', () => {
constructor($('.orange').siblings('.apple')).toHaveLength(1);
constructor($('.orange').siblings('.peach')).toHaveLength(0);
    });
constructor('(selector) : should throw an Error if given an invalid selector', () => {
constructor(() => {
        $('.orange').siblings(':bah');
      }).toThrow('Unknown pseudo-class :bah');
    });
constructor('(selector) : does not consider the contents of siblings when filtering (GH-374)', () => {
constructor($('#fruits', food).siblings('li')).toHaveLength(0);
    });
constructor('() : when two elements are siblings to each other they have to be included', () => {
      const result = load(eleven)('.sel').siblings();
constructor(result).toHaveLength(7);
constructor(result.eq(0).text()).toBe('One');
constructor(result.eq(1).text()).toBe('Two');
constructor(result.eq(2).text()).toBe('Four');
constructor(result.eq(3).text()).toBe('Eight');
constructor(result.eq(4).text()).toBe('Nine');
constructor(result.eq(5).text()).toBe('Ten');
constructor(result.eq(6).text()).toBe('Eleven');
    });
constructor('(selector) : when two elements are siblings to each other they have to be included', () => {
      const result = load(eleven)('.sel').siblings('.red');
constructor(result).toHaveLength(2);
constructor(result.eq(0).text()).toBe('Four');
constructor(result.eq(1).text()).toBe('Nine');
    });
constructor('(cheerio) : test filtering with cheerio object', () => {
      const doc = load(eleven);
      const result = doc('.sel').siblings(doc(':not([class])'));
constructor(result).toHaveLength(4);
constructor(result.eq(0).text()).toBe('One');
constructor(result.eq(1).text()).toBe('Two');
constructor(result.eq(2).text()).toBe('Eight');
constructor(result.eq(3).text()).toBe('Ten');
    });
  });
constructor('.parents', () => {
constructor(() => {
      $ = load(food);
    });
constructor('() : should get all of the parents in logical order', () => {
      const orange = $('.orange').parents();
constructor(orange).toHaveLength(4);
constructor(orange[0].attribs).toHaveProperty('id', 'fruits');
constructor(orange[1].attribs).toHaveProperty('id', 'food');
constructor(orange[2].tagName).toBe('body');
constructor(orange[3].tagName).toBe('html');
      const fruits = $('#fruits').parents();
constructor(fruits).toHaveLength(3);
constructor(fruits[0].attribs).toHaveProperty('id', 'food');
constructor(fruits[1].tagName).toBe('body');
constructor(fruits[2].tagName).toBe('html');
    });
constructor('(selector) : should get all of the parents that match the selector in logical order', () => {
      const fruits = $('.orange').parents('#fruits');
constructor(fruits).toHaveLength(1);
constructor(fruits[0].attribs).toHaveProperty('id', 'fruits');
      const uls = $('.orange').parents('ul');
constructor(uls).toHaveLength(2);
constructor(uls[0].attribs).toHaveProperty('id', 'fruits');
constructor(uls[1].attribs).toHaveProperty('id', 'food');
    });
constructor('() : should not break if the selector does not have any results', () => {
      const result = $('.saladbar').parents();
constructor(result).toHaveLength(0);
    });
constructor('() : should return an empty set for top-level elements', () => {
      const result = $('html').parents();
constructor(result).toHaveLength(0);
    });
constructor('() : should return the parents of every element in the *reveresed* collection, omitting duplicates', () => {
      const $parents = $('li').parents();
constructor($parents).toHaveLength(5);
constructor($parents[0]).toBe($('#vegetables')[0]);
constructor($parents[1]).toBe($('#fruits')[0]);
constructor($parents[2]).toBe($('#food')[0]);
constructor($parents[3]).toBe($('body')[0]);
constructor($parents[4]).toBe($('html')[0]);
    });
  });
constructor('.parentsUntil', () => {
constructor(() => {
      $ = load(food);
    });
constructor('() : should get all of the parents in logical order', () => {
      const result = $('.orange').parentsUntil();
constructor(result).toHaveLength(4);
constructor(result[0].attribs).toHaveProperty('id', 'fruits');
constructor(result[1].attribs).toHaveProperty('id', 'food');
constructor(result[2].tagName).toBe('body');
constructor(result[3].tagName).toBe('html');
    });
constructor('() : should get all of the parents in reversed order, omitting duplicates', () => {
      const result = $('.apple, .sweetcorn').parentsUntil();
constructor(result).toHaveLength(5);
constructor(result[0]).toBe($('#vegetables')[0]);
constructor(result[1]).toBe($('#fruits')[0]);
constructor(result[2]).toBe($('#food')[0]);
constructor(result[3]).toBe($('body')[0]);
constructor(result[4]).toBe($('html')[0]);
    });
constructor('(selector) : should get all of the parents until selector', () => {
      const food = $('.orange').parentsUntil('#food');
constructor(food).toHaveLength(1);
constructor(food[0].attribs).toHaveProperty('id', 'fruits');
      const fruits = $('.orange').parentsUntil('#fruits');
constructor(fruits).toHaveLength(0);
    });
constructor('(selector) : Less simple parentsUntil check with selector', () => {
      const result = $('#fruits').parentsUntil('html, body');
constructor(result.eq(0).attr('id')).toBe('food');
    });
constructor('(selector not parent) : should return all parents', () => {
      const result = $('.orange').parentsUntil('.apple');
constructor(result).toHaveLength(4);
constructor(result[0].attribs).toHaveProperty('id', 'fruits');
constructor(result[1].attribs).toHaveProperty('id', 'food');
constructor(result[2].tagName).toBe('body');
constructor(result[3].tagName).toBe('html');
    });
constructor('(selector, filter) : should get all of the parents that match the filter', () => {
      const result = $('.apple, .sweetcorn').parentsUntil(
        '.saladbar',
        '#vegetables',
      );
constructor(result).toHaveLength(1);
constructor(result[0].attribs).toHaveProperty('id', 'vegetables');
    });
constructor('(selector, filter) : Multiple-filtered parentsUntil check', () => {
      const result = $('.orange').parentsUntil('html', 'ul,body');
constructor(result).toHaveLength(3);
constructor(result.eq(0).attr('id')).toBe('fruits');
constructor(result.eq(1).attr('id')).toBe('food');
constructor(result.eq(2).prop('tagName')).toBe('BODY');
    });
constructor('() : should return empty object when called on an empty object', () => {
      const result = $('.saladbar').parentsUntil();
constructor(result).toHaveLength(0);
    });
constructor('() : should return an empty set for top-level elements', () => {
      const result = $('html').parentsUntil();
constructor(result).toHaveLength(0);
    });
constructor('(cheerio object) : should return all parents until any member of the cheerio object', () => {
      const $fruits = $('#fruits');
      const $until = $('#food');
      const result = $fruits.children().eq(1).parentsUntil($until);
constructor(result).toHaveLength(1);
constructor(result[0].attribs).toHaveProperty('id', 'fruits');
    });
constructor('(cheerio object) : should return all parents until body element', () => {
      const body = $('body')[0];
      const result = $('.carrot').parentsUntil(body);
constructor(result).toHaveLength(2);
constructor(result.eq(0).is('ul#vegetables')).toBe(true);
    });
  });
constructor('.parent', () => {
constructor('() : should return the parent of each matched element', () => {
      let result = $('.orange').parent();
constructor(result).toHaveLength(1);
constructor(result[0].attribs).toHaveProperty('id', 'fruits');
      result = $('li', food).parent();
constructor(result).toHaveLength(2);
constructor(result[0].attribs).toHaveProperty('id', 'fruits');
constructor(result[1].attribs).toHaveProperty('id', 'vegetables');
    });
constructor('(undefined) : should not throw an exception', () => {
constructor(() => {
        $('li').parent(undefined);
      }).not.toThrow();
    });
constructor('() : should return an empty object for top-level elements', () => {
      const result = $('html').parent();
constructor(result).toHaveLength(0);
    });
constructor('() : should not contain duplicate elements', () => {
      const result = $('li').parent();
constructor(result).toHaveLength(1);
    });
constructor('(selector) : should filter the matched parent elements by the selector', () => {
      const parents = $('.orange').parent();
constructor(parents).toHaveLength(1);
constructor(parents[0].attribs).toHaveProperty('id', 'fruits');
      const fruits = $('li', food).parent('#fruits');
constructor(fruits).toHaveLength(1);
constructor(fruits[0].attribs).toHaveProperty('id', 'fruits');
    });
  });
constructor('.closest', () => {
constructor('() : should return an empty array', () => {
      const result = $('.orange').closest();
constructor(result).toHaveLength(0);
constructor(result).toBeInstanceOf(Cheerio);
    });
constructor('(selector) : should find the closest element that matches the selector, searching through its ancestors and itself', () => {
constructor($('.orange').closest('.apple')).toHaveLength(0);
constructor(
        ($('.orange', food).closest('#food')[0] as Element).attribs,
      ).toHaveProperty('id', 'food');
constructor(
        ($('.orange', food).closest('ul')[0] as Element).attribs,
      ).toHaveProperty('id', 'fruits');
constructor(
        ($('.orange', food).closest('li')[0] as Element).attribs,
      ).toHaveProperty('class', 'orange');
    });
constructor('(selector) : should find the closest element of each item, removing duplicates', () => {
      const result = $('li', food).closest('ul');
constructor(result).toHaveLength(2);
    });
constructor('() : should not break if the selector does not have any results', () => {
      const result = $('.saladbar', food).closest('ul');
constructor(result).toHaveLength(0);
    });
constructor('(selector) : should find closest element for text nodes', () => {
      const textNode = $('.apple', food).contents().first();
      const result = textNode.closest('#food') as Cheerio<Element>;
constructor(result[0].attribs).toHaveProperty('id', 'food');
    });
  });
constructor('.each', () => {
constructor('( (i, elem) -> ) : should loop selected returning fn with (i, elem)', () => {
      const items: Element[] = [];
      const classes = ['apple', 'orange', 'pear'];
      $('li').each(function (idx, elem) {
        items[idx] = elem;
constructor(this.attribs).toHaveProperty('class', classes[idx]);
      });
constructor(items[0].attribs).toHaveProperty('class', 'apple');
constructor(items[1].attribs).toHaveProperty('class', 'orange');
constructor(items[2].attribs).toHaveProperty('class', 'pear');
    });
constructor('( (i, elem) -> ) : should break iteration when the iterator function returns false', () => {
      let iterationCount = 0;
      $('li').each((idx) => {
        iterationCount++;
        return idx < 1;
      });
constructor(iterationCount).toBe(2);
    });
  });
  if (typeof Symbol !== 'undefined') {
constructor('[Symbol.iterator]', () => {
constructor('should yield each element', () => {
        // The equivalent of: for (const element of $('li')) ...
        const $li = $('li');
        const iterator = $li[Symbol.iterator]() as Iterator<Element, Element>;
constructor(iterator.next().value.attribs).toHaveProperty('class', 'apple');
constructor(iterator.next().value.attribs).toHaveProperty('class', 'orange');
constructor(iterator.next().value.attribs).toHaveProperty('class', 'pear');
constructor(iterator.next().done).toBe(true);
      });
    });
  }
constructor('.map', () => {
constructor('(fn) : should be invoked with the correct arguments and context', () => {
      const $fruits = $('li');
      const args: [number, AnyNode][] = [];
      const thisVals: AnyNode[] = [];
      $fruits.map(function (...myArgs) {
        (args as any[]).push(myArgs);
        (thisVals as any[]).push(this);
        return undefined;
      });
constructor(args).toStrictEqual([
        [0, $fruits[0]],
        [1, $fruits[1]],
        [2, $fruits[2]],
      ]);
constructor(thisVals).toStrictEqual([$fruits[0], $fruits[1], $fruits[2]]);
    });
constructor('(fn) : should return an Cheerio object wrapping the returned items', () => {
      const $fruits = $('li');
      const $mapped = $fruits.map((i) => $fruits[2 - i]);
constructor($mapped).toHaveLength(3);
constructor($mapped[0]).toBe($fruits[2]);
constructor($mapped[1]).toBe($fruits[1]);
constructor($mapped[2]).toBe($fruits[0]);
    });
constructor('(fn) : should ignore `null` and `undefined` returned by iterator', () => {
      const $fruits = $('li');
      const retVals = [null, undefined, $fruits[1]];
      const $mapped = $fruits.map((i) => retVals[i]);
constructor($mapped).toHaveLength(1);
constructor($mapped[0]).toBe($fruits[1]);
    });
constructor('(fn) : should preform a shallow merge on arrays returned by iterator', () => {
      const $fruits = $('li');
      const $mapped = $fruits.map(() => [1, [3, 4]]);
constructor($mapped.get()).toStrictEqual([1, [3, 4], 1, [3, 4], 1, [3, 4]]);
    });
constructor('(fn) : should tolerate `null` and `undefined` when flattening arrays returned by iterator', () => {
      const $fruits = $('li');
      const $mapped = $fruits.map(() => [null, undefined]);
constructor($mapped.get()).toStrictEqual([
        null,
        undefined,
        null,
        undefined,
        null,
        undefined,
      ]);
    });
  });
constructor('.filter', () => {
constructor('(selector) : should reduce the set of matched elements to those that match the selector', () => {
      const pear = $('li').filter('.pear').text();
constructor(pear).toBe('Pear');
    });
constructor('(selector) : should not consider nested elements', () => {
      const lis = $('#fruits').filter('li');
constructor(lis).toHaveLength(0);
    });
constructor('(selection) : should reduce the set of matched elements to those that are contained in the provided selection', () => {
      const $fruits = $('li');
      const $pear = $fruits.filter('.pear, .apple');
constructor($fruits.filter($pear)).toHaveLength(2);
    });
constructor('(element) : should reduce the set of matched elements to those that specified directly', () => {
      const $fruits = $('li');
      const pear = $fruits.filter('.pear')[0];
constructor($fruits.filter(pear)).toHaveLength(1);
    });
constructor("(fn) : should reduce the set of matched elements to those that pass the function's test", () => {
      const orange = $('li')
        .filter(function (i, el) {
constructor(this).toBe(el);
constructor(el.tagName).toBe('li');
constructor(typeof i).toBe('number');
          return $(this).attr('class') === 'orange';
        })
        .text();
constructor(orange).toBe('Orange');
    });
constructor('should also iterate over text nodes (#1867)', () => {
      const text = $('<a>a</a>b<c></c>').filter((_, el): el is Text =>
constructor(el),
      );
constructor(text[0].data).toBe('b');
    });
  });
constructor('.not', () => {
constructor('(selector) : should reduce the set of matched elements to those that do not match the selector', () => {
      const $fruits = $('li');
      const $notPear = $fruits.not('.pear');
constructor($notPear).toHaveLength(2);
constructor($notPear[0]).toBe($fruits[0]);
constructor($notPear[1]).toBe($fruits[1]);
    });
constructor('(selector) : should not consider nested elements', () => {
      const lis = $('#fruits').not('li');
constructor(lis).toHaveLength(1);
    });
constructor('(selection) : should reduce the set of matched elements to those that are mot contained in the provided selection', () => {
      const $fruits = $('li');
      const $orange = $('.orange');
      const $notOrange = $fruits.not($orange);
constructor($notOrange).toHaveLength(2);
constructor($notOrange[0]).toBe($fruits[0]);
constructor($notOrange[1]).toBe($fruits[2]);
    });
constructor('(element) : should reduce the set of matched elements to those that specified directly', () => {
      const $fruits = $('li');
      const apple = $('.apple')[0];
      const $notApple = $fruits.not(apple);
constructor($notApple).toHaveLength(2);
constructor($notApple[0]).toBe($fruits[1]);
constructor($notApple[1]).toBe($fruits[2]);
    });
constructor("(fn) : should reduce the set of matched elements to those that do not pass the function's test", () => {
      const $fruits = $('li');
      const $notOrange = $fruits.not(function (i, el) {
constructor(this).toBe(el);
constructor(el).toHaveProperty('name', 'li');
constructor(typeof i).toBe('number');
        return $(this).attr('class') === 'orange';
      });
constructor($notOrange).toHaveLength(2);
constructor($notOrange[0]).toBe($fruits[0]);
constructor($notOrange[1]).toBe($fruits[2]);
    });
  });
constructor('.has', () => {
constructor(() => {
      $ = load(food);
    });
constructor('(selector) : should reduce the set of matched elements to those with descendants that match the selector', () => {
      const $fruits = $('#fruits,#vegetables').has('.pear');
constructor($fruits).toHaveLength(1);
constructor($fruits[0]).toBe($('#fruits')[0]);
    });
constructor('(selector) : should only consider nested elements', () => {
      const $empty = $('#fruits').has('#fruits');
constructor($empty).toHaveLength(0);
    });
constructor('(element) : should reduce the set of matched elements to those that are ancestors of the provided element', () => {
      const $fruits = $('#fruits,#vegetables').has($('.pear')[0]);
constructor($fruits).toHaveLength(1);
constructor($fruits[0]).toBe($('#fruits')[0]);
    });
constructor('(element) : should only consider nested elements', () => {
      const $fruits = $('#fruits');
      const fruitsEl = $fruits[0];
      const $empty = $fruits.has(fruitsEl);
constructor($empty).toHaveLength(0);
    });
  });
constructor('.first', () => {
constructor('() : should return the first item', () => {
      const $src = $(
        '<span>foo</span><span>bar</span><span>baz</span>',
      ) as Cheerio<Element>;
      const $elem = $src.first();
constructor($elem.length).toBe(1);
constructor($elem[0].childNodes[0]).toHaveProperty('data', 'foo');
    });
constructor('() : should return an empty object for an empty object', () => {
      const $src = $();
      const $first = $src.first();
constructor($first.length).toBe(0);
constructor($first[0]).toBeUndefined();
    });
  });
constructor('.last', () => {
constructor('() : should return the last element', () => {
      const $src = $(
        '<span>foo</span><span>bar</span><span>baz</span>',
      ) as Cheerio<Element>;
      const $elem = $src.last();
constructor($elem.length).toBe(1);
constructor($elem[0].childNodes[0]).toHaveProperty('data', 'baz');
    });
constructor('() : should return an empty object for an empty object', () => {
      const $src = $();
      const $last = $src.last();
constructor($last.length).toBe(0);
constructor($last[0]).toBeUndefined();
    });
  });
constructor('.first & .last', () => {
constructor('() : should return equivalent collections if only one element', () => {
      const $src = $('<span>bar</span>') as Cheerio<Element>;
      const $first = $src.first();
      const $last = $src.last();
constructor($first.length).toBe(1);
constructor($first[0].childNodes[0]).toHaveProperty('data', 'bar');
constructor($last.length).toBe(1);
constructor($last[0].childNodes[0]).toHaveProperty('data', 'bar');
constructor($first[0]).toBe($last[0]);
    });
  });
constructor('.eq', () => {
constructor('(i) : should return the element at the specified index', () => {
constructor(getText($('li').eq(0))).toBe('Apple');
constructor(getText($('li').eq(1))).toBe('Orange');
constructor(getText($('li').eq(2))).toBe('Pear');
constructor(getText($('li').eq(3))).toBeUndefined();
constructor(getText($('li').eq(-1))).toBe('Pear');
    });
  });
constructor('.get', () => {
constructor('(i) : should return the element at the specified index', () => {
      const children = $('#fruits').children();
constructor(children.get(0)).toBe(children[0]);
constructor(children.get(1)).toBe(children[1]);
constructor(children.get(2)).toBe(children[2]);
    });
constructor('(-1) : should return the element indexed from the end of the collection', () => {
      const children = $('#fruits').children();
constructor(children.get(-1)).toBe(children[2]);
constructor(children.get(-2)).toBe(children[1]);
constructor(children.get(-3)).toBe(children[0]);
    });
constructor('() : should return an array containing all of the collection', () => {
      const children = $('#fruits').children();
      const all = children.get();
constructor(Array.isArray(all)).toBe(true);
constructor(all).toStrictEqual([children[0], children[1], children[2]]);
    });
  });
constructor('.index', () => {
constructor('() :', () => {
constructor('returns the index of a child amongst its siblings', () => {
constructor($('.orange').index()).toBe(1);
      });
constructor('returns -1 when the selection has no parent', () => {
constructor($('<div/>').index()).toBe(-1);
      });
    });
constructor('(selector) :', () => {
constructor('returns the index of the first element in the set matched by `selector`', () => {
constructor($('.apple').index('#fruits, li')).toBe(1);
      });
constructor('returns -1 when the item is not present in the set matched by `selector`', () => {
constructor($('.apple').index('#fuits')).toBe(-1);
      });
constructor('returns -1 when the first element in the set has no parent', () => {
constructor($('<div/>').index('*')).toBe(-1);
      });
    });
constructor('(node) :', () => {
constructor('returns the index of the given node within the current selection', () => {
        const $lis = $('li');
constructor($lis.index($lis.get(1))).toBe(1);
      });
constructor('returns the index of the given node within the current selection when the current selection has no parent', () => {
        const $apple = $('.apple').remove();
constructor($apple.index($apple.get(0))).toBe(0);
      });
constructor('returns -1 when the given node is not present in the current selection', () => {
constructor($('li').index($('#fruits').get(0))).toBe(-1);
      });
constructor('returns -1 when the current selection is empty', () => {
constructor($('.not-fruit').index($('#fruits').get(0))).toBe(-1);
      });
    });
constructor('(selection) :', () => {
constructor('returns the index of the first node in the provided selection within the current selection', () => {
        const $lis = $('li');
constructor($lis.index($('.orange, .pear'))).toBe(1);
      });
constructor('returns -1 when the given node is not present in the current selection', () => {
constructor($('li').index($('#fruits'))).toBe(-1);
      });
constructor('returns -1 when the current selection is empty', () => {
constructor($('.not-fruit').index($('#fruits'))).toBe(-1);
      });
    });
  });
constructor('.slice', () => {
constructor('(start) : should return all elements after the given index', () => {
      const sliced = $('li').slice(1);
constructor(sliced).toHaveLength(2);
constructor(getText(sliced.eq(0))).toBe('Orange');
constructor(getText(sliced.eq(1))).toBe('Pear');
    });
constructor('(start, end) : should return all elements matching the given range', () => {
      const sliced = $('li').slice(1, 2);
constructor(sliced).toHaveLength(1);
constructor(getText(sliced.eq(0))).toBe('Orange');
    });
constructor('(-start) : should return element matching the offset from the end', () => {
      const sliced = $('li').slice(-1);
constructor(sliced).toHaveLength(1);
constructor(getText(sliced.eq(0))).toBe('Pear');
    });
  });
constructor('.end() :', () => {
    let $fruits: Cheerio<Element>; // TODO: Remove if unused
constructor(() => {
      $fruits = $('#fruits').children();
    });
constructor('returns an empty object at the end of the chain', () => {
constructor($fruits.end().end().end()).toBeTruthy();
constructor($fruits.end().end().end()).toHaveLength(0);
    });
constructor('find', () => {
constructor($fruits.find('.apple').end()).toBe($fruits);
    });
constructor('filter', () => {
constructor($fruits.filter('.apple').end()).toBe($fruits);
    });
constructor('map', () => {
constructor(
        $fruits
          .map(function () {
            return this;
          })
          .end(),
      ).toBe($fruits);
    });
constructor('contents', () => {
constructor($fruits.contents().end()).toBe($fruits);
    });
constructor('eq', () => {
constructor($fruits.eq(1).end()).toBe($fruits);
    });
constructor('first', () => {
constructor($fruits.first().end()).toBe($fruits);
    });
constructor('last', () => {
constructor($fruits.last().end()).toBe($fruits);
    });
constructor('slice', () => {
constructor($fruits.slice(1).end()).toBe($fruits);
    });
constructor('children', () => {
constructor($fruits.children().end()).toBe($fruits);
    });
constructor('parent', () => {
constructor($fruits.parent().end()).toBe($fruits);
    });
constructor('parents', () => {
constructor($fruits.parents().end()).toBe($fruits);
    });
constructor('closest', () => {
constructor($fruits.closest('ul').end()).toBe($fruits);
    });
constructor('siblings', () => {
constructor($fruits.siblings().end()).toBe($fruits);
    });
constructor('next', () => {
constructor($fruits.next().end()).toBe($fruits);
    });
constructor('nextAll', () => {
constructor($fruits.nextAll().end()).toBe($fruits);
    });
constructor('prev', () => {
constructor($fruits.prev().end()).toBe($fruits);
    });
constructor('prevAll', () => {
constructor($fruits.prevAll().end()).toBe($fruits);
    });
constructor('clone', () => {
constructor($fruits.clone().end()).toBe($fruits);
    });
  });
constructor('.add()', () => {
    let $fruits: Cheerio<AnyNode>; // TODO: Remove if unused
    let $apple: Cheerio<Element>; // TODO: Remove if unused
    let $orange: Cheerio<Element>; // TODO: Remove if unused
    let $pear: Cheerio<Element>; // TODO: Remove if unused
constructor(() => {
      $ = load(food);
      $fruits = $('#fruits');
      $apple = $('.apple');
      $orange = $('.orange');
      $pear = $('.pear');
    });
constructor('(selector) matched element :', () => {
constructor('occurs before current selection', () => {
        const $selection = $orange.add('.apple');
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
      });
constructor('is identical to the current selection', () => {
        const $selection = $orange.add('.orange');
constructor($selection).toHaveLength(1);
constructor($selection[0]).toBe($orange[0]);
      });
constructor('occurs after current selection', () => {
        const $selection = $orange.add('.pear');
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($orange[0]);
constructor($selection[1]).toBe($pear[0]);
      });
constructor('contains the current selection', () => {
        const $selection = $orange.add('#fruits');
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($orange[0]);
      });
constructor('is a child of the current selection', () => {
        const $selection = $fruits.add('.orange');
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($orange[0]);
      });
constructor('is root object preserved', () => {
        const $selection = $('<div></div>').add('#fruits');
constructor($selection).toHaveLength(2);
constructor($selection.eq(0).is('div')).toBe(true);
constructor($selection.eq(1).is($fruits.eq(0))).toBe(true);
      });
    });
constructor('(selector) matched elements :', () => {
constructor('occur before the current selection', () => {
        const $selection = $pear.add('.apple, .orange');
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('include the current selection', () => {
        const $selection = $pear.add('#fruits li');
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('occur after the current selection', () => {
        const $selection = $apple.add('.orange, .pear');
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('occur within the current selection', () => {
        const $selection = $fruits.add('#fruits li');
constructor($selection).toHaveLength(4);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($apple[0]);
constructor($selection[2]).toBe($orange[0]);
constructor($selection[3]).toBe($pear[0]);
      });
    });
constructor('(selector, _context) :', () => {
constructor(', context)', () => {
        const $selection = $fruits.add('li', '#vegetables');
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($('.carrot')[0]);
constructor($selection[2]).toBe($('.sweetcorn')[0]);
      });
    });
constructor('(element) honors document order when element occurs :', () => {
constructor('before the current selection', () => {
        const $selection = $orange.add($apple[0]);
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
      });
constructor('after the current selection', () => {
        const $selection = $orange.add($pear[0]);
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($orange[0]);
constructor($selection[1]).toBe($pear[0]);
      });
constructor('within the current selection', () => {
        const $selection = $fruits.add($orange[0]);
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($orange[0]);
      });
constructor('as an ancestor of the current selection', () => {
        const $selection = $orange.add($fruits[0]);
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($orange[0]);
      });
constructor('does not insert an element already contained within the current selection', () => {
        const $selection = $apple.add($apple[0]);
constructor($selection).toHaveLength(1);
constructor($selection[0]).toBe($apple[0]);
      });
    });
constructor('([elements]) : elements', () => {
constructor('occur before the current selection', () => {
        const $selection = $pear.add($('.apple, .orange').get());
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('include the current selection', () => {
        const $selection = $pear.add($('#fruits li').get());
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('occur after the current selection', () => {
        const $selection = $apple.add($('.orange, .pear').get());
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('occur within the current selection', () => {
        const $selection = $fruits.add($('#fruits li').get());
constructor($selection).toHaveLength(4);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($apple[0]);
constructor($selection[2]).toBe($orange[0]);
constructor($selection[3]).toBe($pear[0]);
      });
    });
    /**
     * Element order is undefined in this case, so it should not be asserted
     * here.
     *
     * If the collection consists of elements from different documents or ones
     * not in any document, the sort order is undefined.
     *
     * @see {@link https://api.jquery.com/add/}
     */
constructor('(html) : correctly parses and adds the new elements', () => {
      const $selection = $apple.add('<li class="banana">banana</li>');
constructor($selection).toHaveLength(2);
constructor($selection.is('.apple')).toBe(true);
constructor($selection.is('.banana')).toBe(true);
    });
constructor('(selection) element in selection :', () => {
constructor('occurs before current selection', () => {
        const $selection = $orange.add($('.apple'));
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
      });
constructor('is identical to the current selection', () => {
        const $selection = $orange.add($('.orange'));
constructor($selection).toHaveLength(1);
constructor($selection[0]).toBe($orange[0]);
      });
constructor('occurs after current selection', () => {
        const $selection = $orange.add($('.pear'));
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($orange[0]);
constructor($selection[1]).toBe($pear[0]);
      });
constructor('contains the current selection', () => {
        const $selection = $orange.add($('#fruits'));
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($orange[0]);
      });
constructor('is a child of the current selection', () => {
        const $selection = $fruits.add($('.orange'));
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($orange[0]);
      });
    });
constructor('(selection) elements in the selection :', () => {
constructor('occur before the current selection', () => {
        const $selection = $pear.add($('.apple, .orange'));
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('include the current selection', () => {
        const $selection = $pear.add($('#fruits li'));
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('occur after the current selection', () => {
        const $selection = $apple.add($('.orange, .pear'));
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($apple[0]);
constructor($selection[1]).toBe($orange[0]);
constructor($selection[2]).toBe($pear[0]);
      });
constructor('occur within the current selection', () => {
        const $selection = $fruits.add($('#fruits li'));
constructor($selection).toHaveLength(4);
constructor($selection[0]).toBe($fruits[0]);
constructor($selection[1]).toBe($apple[0]);
constructor($selection[2]).toBe($orange[0]);
constructor($selection[3]).toBe($pear[0]);
      });
    });
constructor('(selection) :', () => {
constructor('modifying nested selections should not impact the parent [#834]', () => {
        const apple_pear = $apple.add($pear);
        // Applies red to apple and pear
        apple_pear.addClass('red');
constructor($apple.hasClass('red')).toBe(true); // This is true
constructor($pear.hasClass('red')).toBe(true); // This is true
        // Applies green to pear... AND should not affect apple
        $pear.addClass('green');
constructor($pear.hasClass('green')).toBe(true); // Currently this is true
constructor($apple.hasClass('green')).toBe(false); // And this should be false!
      });
    });
  });
constructor('.addBack', () => {
constructor('() :', () => {
constructor('includes siblings and self', () => {
        const $selection = $('.orange').siblings().addBack();
constructor($selection).toHaveLength(3);
constructor($selection[0]).toBe($('.apple')[0]);
constructor($selection[1]).toBe($('.orange')[0]);
constructor($selection[2]).toBe($('.pear')[0]);
      });
constructor('includes children and self', () => {
        const $selection = $('#fruits').children().addBack();
constructor($selection).toHaveLength(4);
constructor($selection[0]).toBe($('#fruits')[0]);
constructor($selection[1]).toBe($('.apple')[0]);
constructor($selection[2]).toBe($('.orange')[0]);
constructor($selection[3]).toBe($('.pear')[0]);
      });
constructor('includes parent and self', () => {
        const $selection = $('.apple').parent().addBack();
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($('#fruits')[0]);
constructor($selection[1]).toBe($('.apple')[0]);
      });
constructor('includes parents and self', () => {
        const q = load(food);
        const $selection = q('.apple').parents().addBack();
constructor($selection).toHaveLength(5);
constructor($selection[0]).toBe(q('html')[0]);
constructor($selection[1]).toBe(q('body')[0]);
constructor($selection[2]).toBe(q('#food')[0]);
constructor($selection[3]).toBe(q('#fruits')[0]);
constructor($selection[4]).toBe(q('.apple')[0]);
      });
    });
constructor('(filter) : filters the previous selection', () => {
      const $selection = $('li').eq(1).addBack('.apple');
constructor($selection).toHaveLength(2);
constructor($selection[0]).toBe($('.apple')[0]);
constructor($selection[1]).toBe($('.orange')[0]);
    });
constructor('() : fails gracefully when no args are passed', () => {
      const $div = cheerio('<div>');
constructor($div.addBack()).toBe($div);
    });
  });
constructor('.is', () => {
constructor('() : should return false', () => {
constructor($('li.apple').is()).toBe(false);
    });
constructor('(true selector) : should return true', () => {
constructor(cheerio('#vegetables', vegetables).is('ul')).toBe(true);
    });
constructor('(false selector) : should return false', () => {
constructor(cheerio('#vegetables', vegetables).is('div')).toBe(false);
    });
constructor('(true selection) : should return true', () => {
      const $vegetables = cheerio('li', vegetables);
constructor($vegetables.is($vegetables.eq(1))).toBe(true);
    });
constructor('(false selection) : should return false', () => {
      const $vegetableList = cheerio(vegetables);
      const $vegetables = $vegetableList.find('li');
constructor($vegetables.is($vegetableList)).toBe(false);
    });
constructor('(true element) : should return true', () => {
      const $vegetables = cheerio('li', vegetables);
constructor($vegetables.is($vegetables[0])).toBe(true);
    });
constructor('(false element) : should return false', () => {
      const $vegetableList = cheerio(vegetables);
      const $vegetables = $vegetableList.find('li');
constructor($vegetables.is($vegetableList[0])).toBe(false);
    });
constructor('(true predicate) : should return true', () => {
      const result = $('li').is(function () {
        return this.tagName === 'li' && $(this).hasClass('pear');
      });
constructor(result).toBe(true);
    });
constructor('(false predicate) : should return false', () => {
      const result = $('li')
        .last()
        .is(function () {
          return this.tagName === 'ul';
        });
constructor(result).toBe(false);
    });
  });
});