<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Video Clipper - Simple Working Version</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f0f0f0; }
        .container { max-width: 700px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; }
        h1 { color: #333; text-align: center; margin-bottom: 30px; }
        .upload-zone { 
            border: 3px dashed #28a745; 
            padding: 40px; 
            text-align: center; 
            border-radius: 10px; 
            cursor: pointer;
            margin-bottom: 20px;
            background: #f8fff9;
        }
        .upload-zone:hover { background: #e8f5e8; border-color: #1e7e34; }
        .upload-zone.dragover { background: #d4edda; border-color: #155724; }
        input[type="file"] { display: none; }
        video { width: 100%; margin: 20px 0; border-radius: 8px; }
        .controls { display: none; margin-top: 20px; }
        .time-row { display: flex; gap: 20px; margin: 15px 0; }
        .time-row > div { flex: 1; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        input[type="text"] { width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; }
        input[type="text"]:focus { border-color: #28a745; outline: none; }
        button { 
            background: #007bff; color: white; border: none; padding: 12px 20px; 
            border-radius: 8px; cursor: pointer; margin: 5px; font-size: 16px;
            transition: background 0.3s;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #999; cursor: not-allowed; }
        button.success { background: #28a745; }
        button.success:hover { background: #1e7e34; }
        .status { padding: 15px; margin: 15px 0; border-radius: 8px; display: none; }
        .status.success { background: #d4edda; color: #155724; border-left: 4px solid #28a745; }
        .status.error { background: #f8d7da; color: #721c24; border-left: 4px solid #dc3545; }
        .status.info { background: #d1ecf1; color: #0c5460; border-left: 4px solid #0dcaf0; }
        .processing { display: none; text-align: center; padding: 30px; background: #f8f9fa; border-radius: 10px; margin: 20px 0; }
        .progress { width: 100%; height: 30px; background: #e9ecef; border-radius: 15px; overflow: hidden; margin: 20px 0; }
        .progress-fill { 
            height: 100%; background: linear-gradient(90deg, #28a745, #20c997); width: 0%; 
            transition: width 0.5s; display: flex; align-items: center; justify-content: center; 
            color: white; font-weight: bold; font-size: 14px;
        }
        .debug { background: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; }
        .note { background: #fff3cd; color: #856404; padding: 15px; margin: 15px 0; border-radius: 8px; border-left: 4px solid #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Video Clipper - Simple Browser Version</h1>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">Upload ‚Üí Set Times ‚Üí Create Clip</p>
        
        <div class="note">
            <strong>Note:</strong> This version creates clips using the browser's built-in video processing. 
            It works by creating a new video element with the specified time range and allowing you to download the result.
        </div>
        
        <div class="upload-zone" onclick="document.getElementById('fileInput').click();">
            <h2>üìÅ Click to Upload Video File</h2>
            <p>Or drag and drop your video here</p>
            <p><small>Supports: MP4, MOV, WebM (browser-compatible formats)</small></p>
        </div>
        
        <input type="file" id="fileInput" accept="video/*" />
        
        <video id="videoPlayer" controls style="display:none;"></video>
        
        <div class="controls" id="controls">
            <div class="time-row">
                <div>
                    <label>Start Time:</label>
                    <input type="text" id="startTime" placeholder="0:00" value="0:00" />
                    <small>Examples: 0:30, 1:15, 90</small>
                </div>
                <div>
                    <label>End Time:</label>
                    <input type="text" id="endTime" placeholder="1:00" />
                    <small>Examples: 2:30, 1:45, 120</small>
                </div>
            </div>
            
            <div style="text-align: center;">
                <button onclick="setQuick(10)">First 10s</button>
                <button onclick="setQuick(30)">First 30s</button>
                <button onclick="setQuick(60)">First 60s</button>
                <button onclick="useCurrent()">Current ‚Üí End</button>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button id="clipBtn" onclick="createClip()" class="success" style="font-size: 18px; padding: 15px 30px;">
                    üé• Create Video Clip (Browser Method)
                </button>
            </div>
        </div>
        
        <div class="status" id="statusDiv"></div>
        
        <div class="processing" id="processingDiv">
            <h3 id="processingTitle">üîÑ Creating Video Clip...</h3>
            <div class="progress">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <p id="processingText">Preparing...</p>
        </div>
        
        <div class="debug" id="debugLog" style="display: block;">
            <strong>Debug Log:</strong><br>
        </div>
    </div>

    <script>
        let currentVideo = null;
        let videoBlob = null;

        function debugLog(message) {
            console.log('[DEBUG]', message);
            const debugDiv = document.getElementById('debugLog');
            debugDiv.innerHTML += new Date().toLocaleTimeString() + ': ' + message + '<br>';
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        // Start initialization immediately
        window.addEventListener('load', function() {
            debugLog('Browser-based video clipper loaded');
            debugLog('No FFmpeg required - using browser APIs');
            setupUpload();
            showStatus('‚úÖ Ready! Upload a video to start clipping.', 'success');
        });

        function setupUpload() {
            debugLog('Setting up upload handlers...');
            const uploadZone = document.querySelector('.upload-zone');
            const fileInput = document.getElementById('fileInput');
            
            // Drag and drop handlers
            uploadZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });
            
            uploadZone.addEventListener('dragleave', function(e) {
                uploadZone.classList.remove('dragover');
            });
            
            uploadZone.addEventListener('drop', function(e) {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    debugLog('File dropped: ' + files[0].name);
                    handleFileSelect(files[0]);
                }
            });
            
            // File input handler
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    debugLog('File selected: ' + e.target.files[0].name);
                    handleFileSelect(e.target.files[0]);
                }
            });
            
            debugLog('Upload handlers set up successfully');
        }

        function handleFileSelect(file) {
            debugLog('Processing file: ' + file.name + ' (' + file.type + ', ' + (file.size/1024/1024).toFixed(1) + 'MB)');
            
            if (!file.type.startsWith('video/')) {
                showStatus('‚ùå Please select a video file! Selected: ' + file.type, 'error');
                return;
            }

            showStatus('üì• Loading video: ' + file.name, 'info');
            currentVideo = file;
            videoBlob = file; // Store the original blob
            
            const videoPlayer = document.getElementById('videoPlayer');
            const videoUrl = URL.createObjectURL(file);
            videoPlayer.src = videoUrl;
            videoPlayer.style.display = 'block';
            
            videoPlayer.onloadedmetadata = function() {
                debugLog('Video metadata loaded. Duration: ' + videoPlayer.duration + 's');
                document.getElementById('controls').style.display = 'block';
                document.getElementById('endTime').value = formatTime(videoPlayer.duration);
                showStatus(`‚úÖ Video loaded: ${file.name} (${formatTime(videoPlayer.duration)})`, 'success');
            };
            
            videoPlayer.onerror = function(e) {
                debugLog('Video loading error: ' + e.toString());
                showStatus('‚ùå Error loading video file!', 'error');
            };
        }

        function parseTime(timeStr) {
            if (!timeStr) return 0;
            
            if (timeStr.includes(':')) {
                const parts = timeStr.split(':').map(p => parseFloat(p));
                if (parts.length === 2) {
                    return parts[0] * 60 + parts[1];
                } else if (parts.length === 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                }
            }
            
            return parseFloat(timeStr) || 0;
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function setQuick(duration) {
            debugLog('Setting quick duration: ' + duration + 's');
            document.getElementById('startTime').value = '0:00';
            document.getElementById('endTime').value = formatTime(duration);
        }

        function useCurrent() {
            const videoPlayer = document.getElementById('videoPlayer');
            if (videoPlayer.currentTime > 0) {
                const currentTime = formatTime(videoPlayer.currentTime);
                debugLog('Using current video time as end: ' + currentTime);
                document.getElementById('endTime').value = currentTime;
            }
        }

        async function createClip() {
            debugLog('=== Starting browser-based clip creation ===');
            
            if (!currentVideo) {
                showStatus('‚ùå No video file loaded!', 'error');
                debugLog('Clip creation aborted: No video file');
                return;
            }

            const startTime = document.getElementById('startTime').value;
            const endTime = document.getElementById('endTime').value;
            debugLog('Input times - Start: "' + startTime + '", End: "' + endTime + '"');
            
            const startSeconds = parseTime(startTime);
            const endSeconds = parseTime(endTime);
            const duration = endSeconds - startSeconds;

            debugLog('Calculated - Start: ' + startSeconds + 's, End: ' + endSeconds + 's, Duration: ' + duration + 's');

            if (duration <= 0) {
                showStatus('‚ùå End time must be after start time!', 'error');
                debugLog('Clip creation aborted: Invalid duration');
                return;
            }

            try {
                showProcessing();
                updateProcessingText('üé• Creating video clip using browser MediaRecorder...');
                updateProgress(10);
                
                // Create a new video element for clipping
                const videoElement = document.createElement('video');
                videoElement.src = URL.createObjectURL(currentVideo);
                videoElement.muted = true;
                
                await new Promise((resolve, reject) => {
                    videoElement.onloadedmetadata = resolve;
                    videoElement.onerror = reject;
                });
                
                debugLog('Video element ready for clipping');
                updateProgress(20);
                
                // Set up canvas for video frames
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = videoElement.videoWidth || 640;
                canvas.height = videoElement.videoHeight || 480;
                
                debugLog('Canvas setup: ' + canvas.width + 'x' + canvas.height);
                updateProgress(30);
                
                // Set up MediaRecorder
                const canvasStream = canvas.captureStream(30); // 30 FPS
                const recorder = new MediaRecorder(canvasStream, {
                    mimeType: 'video/webm;codecs=vp8'
                });
                
                const chunks = [];
                recorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chunks.push(event.data);
                    }
                };
                
                updateProcessingText('üé¨ Recording video frames...');
                updateProgress(40);
                
                // Start recording
                recorder.start();
                
                // Set video to start time
                videoElement.currentTime = startSeconds;
                
                await new Promise(resolve => {
                    videoElement.onseeked = resolve;
                });
                
                debugLog('Video seeked to start time: ' + startSeconds + 's');
                updateProgress(50);
                
                // Play and capture frames
                const startTime = performance.now();
                const targetDuration = duration * 1000; // Convert to milliseconds
                
                videoElement.play();
                
                const drawFrame = () => {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / targetDuration, 1);
                    
                    // Draw current video frame to canvas
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    
                    // Update progress
                    updateProgress(50 + (progress * 40));
                    
                    if (progress < 1 && !videoElement.ended) {
                        requestAnimationFrame(drawFrame);
                    } else {
                        // Stop recording
                        recorder.stop();
                        videoElement.pause();
                        debugLog('Recording completed');
                        updateProgress(90);
                    }
                };
                
                drawFrame();
                
                // Wait for recording to finish
                const blob = await new Promise((resolve) => {
                    recorder.onstop = () => {
                        const videoBlob = new Blob(chunks, { type: 'video/webm' });
                        resolve(videoBlob);
                    };
                });
                
                debugLog('Video blob created, size: ' + blob.size + ' bytes');
                updateProgress(95);
                
                // Create download
                const downloadUrl = URL.createObjectURL(blob);
                const outputName = currentVideo.name.replace(/\.[^/.]+$/, '') + '_clip.webm';
                debugLog('Creating download with filename: ' + outputName);
                
                // Create download element and trigger immediately
                const downloadLink = document.createElement('a');
                downloadLink.href = downloadUrl;
                downloadLink.download = outputName;
                downloadLink.style.display = 'none';
                document.body.appendChild(downloadLink);
                
                // Force immediate download
                downloadLink.click();
                debugLog('DOWNLOAD TRIGGERED! File: ' + outputName);
                
                // Clean up after a delay
                setTimeout(() => {
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(downloadUrl);
                }, 1000);
                
                updateProgress(100);
                hideProcessing();
                
                // Show manual download button as backup
                const manualDownloadBtn = document.createElement('button');
                manualDownloadBtn.textContent = 'üì• Download Video Clip (' + formatTime(duration) + ')';
                manualDownloadBtn.className = 'success';
                manualDownloadBtn.style.cssText = 'font-size: 18px; padding: 15px 25px; margin: 20px 10px;';
                manualDownloadBtn.onclick = function() {
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = outputName;
                    a.click();
                    debugLog('Manual download button clicked');
                };
                
                showStatus(`‚úÖ Video clip created successfully! Duration: ${formatTime(duration)}`, 'success');
                const statusDiv = document.getElementById('statusDiv');
                statusDiv.appendChild(document.createElement('br'));
                statusDiv.appendChild(manualDownloadBtn);
                
                debugLog('=== Browser-based clip creation completed successfully ===');
                
            } catch (error) {
                hideProcessing();
                debugLog('ERROR during clip creation: ' + error.message);
                debugLog('Error stack: ' + (error.stack || 'No stack trace'));
                showStatus('‚ùå Clipping failed: ' + error.message, 'error');
                console.error('Clipping error:', error);
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusDiv');
            statusDiv.innerHTML = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }

        function showProcessing() {
            document.getElementById('processingDiv').style.display = 'block';
            document.getElementById('controls').style.display = 'none';
        }

        function hideProcessing() {
            document.getElementById('processingDiv').style.display = 'none';
            document.getElementById('controls').style.display = 'block';
        }

        function updateProgress(percent) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = percent + '%';
            progressFill.textContent = percent + '%';
        }

        function updateProcessingText(text) {
            document.getElementById('processingText').textContent = text;
        }
    </script>
</body>
</html>