<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Video Clipper - Simple Working Version</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f0f0f0; }
        .container { max-width: 700px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; }
        h1 { color: #333; text-align: center; margin-bottom: 30px; }
        .upload-zone { 
            border: 3px dashed #28a745; 
            padding: 40px; 
            text-align: center; 
            border-radius: 10px; 
            cursor: pointer;
            margin-bottom: 20px;
            background: #f8fff9;
        }
        .upload-zone:hover { background: #e8f5e8; border-color: #1e7e34; }
        .upload-zone.dragover { background: #d4edda; border-color: #155724; }
        input[type="file"] { display: none; }
        video { width: 100%; margin: 20px 0; border-radius: 8px; }
        .controls { display: none; margin-top: 20px; }
        .time-row { display: flex; gap: 20px; margin: 15px 0; }
        .time-row > div { flex: 1; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        input[type="text"] { width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; }
        input[type="text"]:focus { border-color: #28a745; outline: none; }
        button { 
            background: #007bff; color: white; border: none; padding: 12px 20px; 
            border-radius: 8px; cursor: pointer; margin: 5px; font-size: 16px;
            transition: background 0.3s;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #999; cursor: not-allowed; }
        button.success { background: #28a745; }
        button.success:hover { background: #1e7e34; }
        .status { padding: 15px; margin: 15px 0; border-radius: 8px; display: none; }
        .status.success { background: #d4edda; color: #155724; border-left: 4px solid #28a745; }
        .status.error { background: #f8d7da; color: #721c24; border-left: 4px solid #dc3545; }
        .status.info { background: #d1ecf1; color: #0c5460; border-left: 4px solid #0dcaf0; }
        .processing { display: none; text-align: center; padding: 30px; background: #f8f9fa; border-radius: 10px; margin: 20px 0; }
        .progress { width: 100%; height: 30px; background: #e9ecef; border-radius: 15px; overflow: hidden; margin: 20px 0; }
        .progress-fill { 
            height: 100%; background: linear-gradient(90deg, #28a745, #20c997); width: 0%; 
            transition: width 0.5s; display: flex; align-items: center; justify-content: center; 
            color: white; font-weight: bold; font-size: 14px;
        }
        .debug { background: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; }
        .note { background: #fff3cd; color: #856404; padding: 15px; margin: 15px 0; border-radius: 8px; border-left: 4px solid #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Video Clipper - Simple Browser Version</h1>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">Upload ‚Üí Set Times ‚Üí Create Clip</p>
        
        <div class="note">
            <strong>Note:</strong> This version creates clips using the browser's built-in video and audio processing.
            It captures both video frames and audio from your original video, preserving audio quality and synchronization.
            If audio capture is not supported by your browser, a video-only clip will be created.
        </div>
        
        <div class="upload-zone" onclick="document.getElementById('fileInput').click();">
            <h2>üìÅ Click to Upload Video File</h2>
            <p>Or drag and drop your video here</p>
            <p><small>Supports: MP4, MOV, WebM (browser-compatible formats)</small></p>
        </div>
        
        <input type="file" id="fileInput" accept="video/*" />
        
        <video id="videoPlayer" controls style="display:none;"></video>
        
        <div class="controls" id="controls">
            <div class="time-row">
                <div>
                    <label>Start Time:</label>
                    <input type="text" id="startTime" placeholder="0:00" value="0:00" />
                    <small>Examples: 0:30, 1:15, 90</small>
                </div>
                <div>
                    <label>End Time:</label>
                    <input type="text" id="endTime" placeholder="1:00" />
                    <small>Examples: 2:30, 1:45, 120</small>
                </div>
            </div>
            
            <div style="text-align: center;">
                <button onclick="setQuick(10)">First 10s</button>
                <button onclick="setQuick(30)">First 30s</button>
                <button onclick="setQuick(60)">First 60s</button>
                <button onclick="useCurrent()">Current ‚Üí End</button>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button id="clipBtn" onclick="createClip()" class="success" style="font-size: 18px; padding: 15px 30px;">
                    üé• Create Video Clip (Browser Method)
                </button>
            </div>
        </div>
        
        <div class="status" id="statusDiv"></div>
        
        <div class="processing" id="processingDiv">
            <h3 id="processingTitle">üîÑ Creating Video Clip...</h3>
            <div class="progress">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <p id="processingText">Preparing...</p>
        </div>
        
        <div class="debug" id="debugLog" style="display: block;">
            <strong>Debug Log:</strong><br>
        </div>
    </div>

    <script>
        let currentVideo = null;
        let videoBlob = null;

        function debugLog(message) {
            console.log('[DEBUG]', message);
            const debugDiv = document.getElementById('debugLog');
            debugDiv.innerHTML += new Date().toLocaleTimeString() + ': ' + message + '<br>';
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        // Start initialization immediately
        window.addEventListener('load', function() {
            debugLog('Browser-based video clipper loaded');
            debugLog('No FFmpeg required - using browser APIs');
            setupUpload();
            showStatus('‚úÖ Ready! Upload a video to start clipping.', 'success');
        });

        function setupUpload() {
            debugLog('Setting up upload handlers...');
            const uploadZone = document.querySelector('.upload-zone');
            const fileInput = document.getElementById('fileInput');
            
            // Drag and drop handlers
            uploadZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });
            
            uploadZone.addEventListener('dragleave', function(e) {
                uploadZone.classList.remove('dragover');
            });
            
            uploadZone.addEventListener('drop', function(e) {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    debugLog('File dropped: ' + files[0].name);
                    handleFileSelect(files[0]);
                }
            });
            
            // File input handler
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    debugLog('File selected: ' + e.target.files[0].name);
                    handleFileSelect(e.target.files[0]);
                }
            });
            
            debugLog('Upload handlers set up successfully');
        }

        function handleFileSelect(file) {
            debugLog('Processing file: ' + file.name + ' (' + file.type + ', ' + (file.size/1024/1024).toFixed(1) + 'MB)');
            
            if (!file.type.startsWith('video/')) {
                showStatus('‚ùå Please select a video file! Selected: ' + file.type, 'error');
                return;
            }

            showStatus('üì• Loading video: ' + file.name, 'info');
            currentVideo = file;
            videoBlob = file; // Store the original blob
            
            const videoPlayer = document.getElementById('videoPlayer');
            const videoUrl = URL.createObjectURL(file);
            videoPlayer.src = videoUrl;
            videoPlayer.style.display = 'block';
            
            videoPlayer.onloadedmetadata = function() {
                debugLog('Video metadata loaded. Duration: ' + videoPlayer.duration + 's');
                document.getElementById('controls').style.display = 'block';
                document.getElementById('endTime').value = formatTime(videoPlayer.duration);
                showStatus(`‚úÖ Video loaded: ${file.name} (${formatTime(videoPlayer.duration)})`, 'success');
            };
            
            videoPlayer.onerror = function(e) {
                debugLog('Video loading error: ' + e.toString());
                showStatus('‚ùå Error loading video file!', 'error');
            };
        }

        function parseTime(timeStr) {
            if (!timeStr) return 0;
            
            if (timeStr.includes(':')) {
                const parts = timeStr.split(':').map(p => parseFloat(p));
                if (parts.length === 2) {
                    return parts[0] * 60 + parts[1];
                } else if (parts.length === 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                }
            }
            
            return parseFloat(timeStr) || 0;
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function setQuick(duration) {
            debugLog('Setting quick duration: ' + duration + 's');
            document.getElementById('startTime').value = '0:00';
            document.getElementById('endTime').value = formatTime(duration);
        }

        function useCurrent() {
            const videoPlayer = document.getElementById('videoPlayer');
            if (videoPlayer.currentTime > 0) {
                const currentTime = formatTime(videoPlayer.currentTime);
                debugLog('Using current video time as end: ' + currentTime);
                document.getElementById('endTime').value = currentTime;
            }
        }

        async function createClip() {
            debugLog('=== Starting browser-based clip creation ===');

            if (!currentVideo) {
                showStatus('‚ùå No video file loaded!', 'error');
                debugLog('Clip creation aborted: No video file');
                return;
            }

            // Check browser compatibility for audio features
            if (!window.AudioContext && !window.webkitAudioContext) {
                showStatus('‚ö†Ô∏è Audio capture not supported on this browser. Video-only clip will be created.', 'info');
                debugLog('AudioContext not available - proceeding with video-only');
            } else {
                debugLog('AudioContext available - audio capture will be included');
            }

            const startTime = document.getElementById('startTime').value;
            const endTime = document.getElementById('endTime').value;
            debugLog('Input times - Start: "' + startTime + '", End: "' + endTime + '"');
            
            const startSeconds = parseTime(startTime);
            const endSeconds = parseTime(endTime);
            const duration = endSeconds - startSeconds;

            debugLog('Calculated - Start: ' + startSeconds + 's, End: ' + endSeconds + 's, Duration: ' + duration + 's');

            if (duration <= 0) {
                showStatus('‚ùå End time must be after start time!', 'error');
                debugLog('Clip creation aborted: Invalid duration');
                return;
            }

            try {
                showProcessing();
                updateProcessingText('üé• Creating video clip using browser MediaRecorder...');
                updateProgress(10);

                // Notify other agents that clip creation has started
                notifyOtherAgents('CLIP_CREATION_STARTED', {
                    filename: currentVideo.name,
                    startTime: startSeconds,
                    endTime: endSeconds,
                    duration: duration
                });
                
                // Create a new video element for clipping
                const videoElement = document.createElement('video');
                videoElement.src = URL.createObjectURL(currentVideo);
                videoElement.muted = false; // Must be unmuted to capture audio
                videoElement.volume = 0.5; // Set reasonable volume for audio capture
                
                await new Promise((resolve, reject) => {
                    videoElement.onloadedmetadata = resolve;
                    videoElement.onerror = reject;
                });
                
                debugLog('Video element ready for clipping');
                updateProgress(20);
                
                // Set up canvas for video frames
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = videoElement.videoWidth || 640;
                canvas.height = videoElement.videoHeight || 480;
                
                debugLog('Canvas setup: ' + canvas.width + 'x' + canvas.height);
                updateProgress(30);
                
                // Set up MediaRecorder with video stream and optional audio
                const canvasStream = canvas.captureStream(30); // 30 FPS
                let combinedStream = canvasStream;
                let audioContext = null;

                // Try to add audio if browser supports it
                if (window.AudioContext || window.webkitAudioContext) {
                    try {
                        debugLog('Setting up audio capture...');
                        updateProcessingText('üéµ Extracting audio from video...');
                        updateProgress(35);

                        audioContext = new (window.AudioContext || window.webkitAudioContext)();

                        // Ensure audio context is resumed (required by some browsers)
                        if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                            debugLog('Audio context resumed');
                        }

                        const audioSource = audioContext.createMediaElementSource(videoElement);
                        const audioDestination = audioContext.createMediaStreamDestination();

                        // Connect audio source to destination (this preserves original audio)
                        audioSource.connect(audioDestination);
                        // Also connect to default output so we can hear it if needed (but keep it quiet)
                        const gainNode = audioContext.createGain();
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Very quiet monitoring
                        audioSource.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        debugLog('Audio context created and connected');

                        // Notify other agents about audio setup
                        notifyOtherAgents('AUDIO_CAPTURE_SETUP', {
                            audioContextState: audioContext.state,
                            sampleRate: audioContext.sampleRate
                        });

                        const audioStream = audioDestination.stream;

                        // Combine video and audio tracks
                        combinedStream = new MediaStream();
                        canvasStream.getVideoTracks().forEach(track => combinedStream.addTrack(track));
                        audioStream.getAudioTracks().forEach(track => combinedStream.addTrack(track));

                        debugLog('Video tracks: ' + canvasStream.getVideoTracks().length + ', Audio tracks: ' + audioStream.getAudioTracks().length);
                        debugLog('Combined stream - Video: ' + combinedStream.getVideoTracks().length + ', Audio: ' + combinedStream.getAudioTracks().length);
                    } catch (audioError) {
                        debugLog('Audio capture failed, falling back to video-only: ' + audioError.message);
                        combinedStream = canvasStream; // Fallback to video-only
                        if (audioContext && audioContext.state !== 'closed') {
                            audioContext.close();
                            audioContext = null;
                        }
                    }
                } else {
                    debugLog('Audio capture not supported, using video-only stream');
                    updateProgress(35);
                }

                // Select appropriate codec based on audio availability
                let mimeType = 'video/mp4';
                const hasAudio = combinedStream.getAudioTracks().length > 0;

                const codecOptions = hasAudio ? [
                    // Audio + Video codec combinations
                    'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
                    'video/webm; codecs="vp8, opus"',
                    'video/webm; codecs="vp9, opus"',
                    'video/mp4',
                    'video/webm'
                ] : [
                    // Video-only codec combinations
                    'video/mp4; codecs="avc1.42E01E"',
                    'video/webm; codecs="vp8"',
                    'video/webm; codecs="vp9"',
                    'video/mp4',
                    'video/webm'
                ];

                for (const option of codecOptions) {
                    if (MediaRecorder.isTypeSupported(option)) {
                        mimeType = option;
                        debugLog('Using MIME type: ' + mimeType + (hasAudio ? ' (with audio)' : ' (video only)'));
                        break;
                    }
                }

                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    debugLog('Warning: Selected MIME type may not be fully supported: ' + mimeType);
                }

                // Configure recorder options based on available tracks
                const recorderOptions = {
                    mimeType: mimeType,
                    videoBitsPerSecond: 2500000 // 2.5 Mbps for good video quality
                };

                // Only set audio bitrate if audio is available
                if (hasAudio) {
                    recorderOptions.audioBitsPerSecond = 128000; // 128 kbps for good audio quality
                }

                const recorder = new MediaRecorder(combinedStream, recorderOptions);
                
                const chunks = [];
                recorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chunks.push(event.data);
                    }
                };
                
                updateProcessingText(hasAudio ? 'üé¨ Recording video and audio...' : 'üé¨ Recording video frames...');
                updateProgress(40);
                
                // Start recording
                recorder.start();
                
                // Set video to start time
                videoElement.currentTime = startSeconds;
                
                await new Promise(resolve => {
                    videoElement.onseeked = resolve;
                });
                
                debugLog('Video seeked to start time: ' + startSeconds + 's');
                updateProgress(50);
                
                // Play and capture frames
                const startTime = performance.now();
                const targetDuration = duration * 1000; // Convert to milliseconds
                
                videoElement.play();
                
                const drawFrame = () => {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / targetDuration, 1);
                    
                    // Draw current video frame to canvas
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    
                    // Update progress
                    updateProgress(50 + (progress * 40));
                    
                    if (progress < 1 && !videoElement.ended) {
                        requestAnimationFrame(drawFrame);
                    } else {
                        // Stop recording
                        recorder.stop();
                        videoElement.pause();
                        // Clean up audio context
                        if (audioContext && audioContext.state !== 'closed') {
                            audioContext.close();
                            debugLog('Audio context closed');
                        }
                        debugLog('Recording completed');
                        updateProgress(90);
                    }
                };
                
                drawFrame();
                
                // Wait for recording to finish
                const blob = await new Promise((resolve) => {
                    recorder.onstop = () => {
                        // Use the same mimeType that was used for recording
                        const videoBlob = new Blob(chunks, { type: mimeType });
                        resolve(videoBlob);
                    };
                });
                
                debugLog('Video blob created, size: ' + blob.size + ' bytes');
                updateProgress(95);
                
                // Create download
                const downloadUrl = URL.createObjectURL(blob);
                // Use MP4 extension when possible, WebM as fallback
                const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';
                const outputName = currentVideo.name.replace(/\.[^/.]+$/, '') + '_clip' + extension;
                debugLog('Creating download with filename: ' + outputName);
                
                // Create download element and trigger immediately
                const downloadLink = document.createElement('a');
                downloadLink.href = downloadUrl;
                downloadLink.download = outputName;
                downloadLink.style.display = 'none';
                document.body.appendChild(downloadLink);
                
                // Force immediate download
                downloadLink.click();
                debugLog('DOWNLOAD TRIGGERED! File: ' + outputName);
                
                // Clean up after a delay
                setTimeout(() => {
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(downloadUrl);
                }, 1000);
                
                updateProgress(100);
                hideProcessing();
                
                // Show manual download button as backup
                const manualDownloadBtn = document.createElement('button');
                manualDownloadBtn.textContent = 'üì• Download Video Clip (' + formatTime(duration) + ')';
                manualDownloadBtn.className = 'success';
                manualDownloadBtn.style.cssText = 'font-size: 18px; padding: 15px 25px; margin: 20px 10px;';
                manualDownloadBtn.onclick = function() {
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = outputName;
                    a.click();
                    debugLog('Manual download button clicked');
                };
                
                showStatus(`‚úÖ Video clip created successfully! Duration: ${formatTime(duration)}`, 'success');
                const statusDiv = document.getElementById('statusDiv');
                statusDiv.appendChild(document.createElement('br'));
                statusDiv.appendChild(manualDownloadBtn);

                // Notify other agents about successful completion
                notifyOtherAgents('CLIP_CREATION_COMPLETED', {
                    filename: outputName,
                    hasAudio: hasAudio,
                    mimeType: mimeType,
                    duration: duration,
                    fileSize: blob.size
                });

                debugLog('=== Browser-based clip creation completed successfully ===');
                
            } catch (error) {
                // Clean up audio context if it exists
                if (typeof audioContext !== 'undefined' && audioContext && audioContext.state !== 'closed') {
                    try {
                        audioContext.close();
                        debugLog('Audio context cleaned up after error');
                    } catch (e) {
                        debugLog('Error cleaning up audio context: ' + e.message);
                    }
                }

                hideProcessing();
                debugLog('ERROR during clip creation: ' + error.message);
                debugLog('Error stack: ' + (error.stack || 'No stack trace'));

                // Provide helpful error messages for common audio issues
                let errorMessage = error.message;
                if (error.message.includes('AudioContext')) {
                    errorMessage += ' (Audio may not be supported on this device/browser)';
                } else if (error.message.includes('MediaRecorder')) {
                    errorMessage += ' (Video recording with audio may not be supported)';
                }

                showStatus('‚ùå Clipping failed: ' + errorMessage, 'error');
                console.error('Clipping error:', error);
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusDiv');
            statusDiv.innerHTML = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }

        function showProcessing() {
            document.getElementById('processingDiv').style.display = 'block';
            document.getElementById('controls').style.display = 'none';
        }

        function hideProcessing() {
            document.getElementById('processingDiv').style.display = 'none';
            document.getElementById('controls').style.display = 'block';
        }

        function updateProgress(percent) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = percent + '%';
            progressFill.textContent = percent + '%';
        }

        function updateProcessingText(text) {
            document.getElementById('processingText').textContent = text;
        }

        // Test function to check browser capabilities
        function testBrowserCapabilities() {
            debugLog('=== Browser Audio/Video Capabilities Test ===');

            // Test AudioContext support
            const hasAudioContext = !!(window.AudioContext || window.webkitAudioContext);
            debugLog('AudioContext support: ' + (hasAudioContext ? 'YES' : 'NO'));

            // Test MediaRecorder support
            const hasMediaRecorder = !!window.MediaRecorder;
            debugLog('MediaRecorder support: ' + (hasMediaRecorder ? 'YES' : 'NO'));

            if (hasMediaRecorder) {
                // Test supported MIME types
                const testMimeTypes = [
                    'video/mp4',
                    'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
                    'video/webm',
                    'video/webm; codecs="vp8, opus"',
                    'video/webm; codecs="vp9, opus"'
                ];

                debugLog('Supported MIME types:');
                testMimeTypes.forEach(mimeType => {
                    const isSupported = MediaRecorder.isTypeSupported(mimeType);
                    debugLog('  ' + mimeType + ': ' + (isSupported ? 'YES' : 'NO'));
                });
            }

            debugLog('=== End Browser Capabilities Test ===');
        }

        // Hook system for coordinating with other agents
        function notifyOtherAgents(event, data) {
            // Post messages that other agents can listen for
            if (typeof window !== 'undefined' && window.postMessage) {
                window.postMessage({
                    source: 'BROWSER_AUDIO_ENGINEER',
                    event: event,
                    data: data,
                    timestamp: new Date().toISOString()
                }, '*');
            }
            debugLog('Notified other agents: ' + event + ' - ' + JSON.stringify(data));
        }

        // Listen for messages from other agents
        window.addEventListener('message', function(event) {
            if (event.data && event.data.source && event.data.source !== 'BROWSER_AUDIO_ENGINEER') {
                debugLog('Received message from ' + event.data.source + ': ' + event.data.event);
                // Handle coordination messages here if needed
            }
        });

        // Run capability test on load
        window.addEventListener('load', function() {
            testBrowserCapabilities();
            notifyOtherAgents('AUDIO_ENGINEER_READY', {
                audioSupport: !!(window.AudioContext || window.webkitAudioContext),
                mediaRecorderSupport: !!window.MediaRecorder
            });
        });
    </script>
</body>
</html>